                        .module main.c
                        .area text(rom, con, rel)
 0000                   .dbfile ./main.c
                        .area lit(rom, con, rel, lit)
 0000           _ip_to_Vout_Lookup::
 0000 0001              .byte 0,1
 0002 0102              .byte 1,2
 0004 0304              .byte 3,4
 0006 0405              .byte 4,5
 0008 0607              .byte 6,7
 000A 0808              .byte 8,8
 000C 090A              .byte 9,10
 000E 0B0C              .byte 11,12
 0010 0C0D              .byte 12,13
 0012 0E0F              .byte 14,15
 0014 1011              .byte 16,17
 0016 1112              .byte 17,18
 0018 1314              .byte 19,20
 001A 1516              .byte 21,22
 001C 1617              .byte 22,23
 001E 1819              .byte 24,25
 0020 1A1B              .byte 26,27
 0022 1B1C              .byte 27,28
 0024 1D1E              .byte 29,30
 0026 1F20              .byte 31,32
 0028 2122              .byte 33,34
 002A 2223              .byte 34,35
 002C 2425              .byte 36,37
 002E 2627              .byte 38,39
 0030 2829              .byte 40,41
 0032 2A2B              .byte 42,43
 0034 2C2C              .byte 44,44
 0036 2D2E              .byte 45,46
 0038 2F30              .byte 47,48
 003A 3132              .byte 49,50
 003C 3334              .byte 51,52
 003E 3536              .byte 53,54
 0040 3738              .byte 55,56
 0042 393A              .byte 57,58
 0044 3B3C              .byte 59,60
 0046 3D3E              .byte 61,62
 0048 3F40              .byte 63,64
 004A 4142              .byte 'A,'B
 004C 4344              .byte 'C,'D
 004E 4546              .byte 'E,'F
 0050 4748              .byte 'G,'H
 0052 494A              .byte 'I,'J
 0054 4C4D              .byte 'L,'M
 0056 4E4F              .byte 'N,'O
 0058 5051              .byte 'P,'Q
 005A 5253              .byte 'R,'S
 005C 5456              .byte 'T,'V
 005E 5758              .byte 'W,'X
 0060 595A              .byte 'Y,'Z
 0062 5B5C              .byte 91,92
 0064 5E5F              .byte 94,95
 0066 6061              .byte 96,'a
 0068 6264              .byte 'b,'d
 006A 6566              .byte 'e,'f
 006C 6769              .byte 'g,'i
 006E 6A6B              .byte 'j,'k
 0070 6C6E              .byte 'l,'n
 0072 6F70              .byte 'o,'p
 0074 7173              .byte 'q,'s
 0076 7475              .byte 't,'u
 0078 7778              .byte 'w,'x
 007A 7B7E              .byte 123,126
 007C 8184              .byte 129,132
 007E 878A              .byte 135,138
 0080 8D90              .byte 141,144
 0082 9397              .byte 147,151
 0084 9A9D              .byte 154,157
 0086 A1A4              .byte 161,164
 0088 A8AB              .byte 168,171
 008A AFB2              .byte 175,178
 008C B6BA              .byte 182,186
 008E BEC2              .byte 190,194
 0090 C5C9              .byte 197,201
 0092 CED2              .byte 206,210
 0094 D6DA              .byte 214,218
 0096 DEE3              .byte 222,227
 0098 E7EC              .byte 231,236
 009A F0F5              .byte 240,245
 009C FAFF              .byte 250,255
 009E                   .dbfile I:\PSOCDO~1\WBOOS_~2\DSTAGE~1\DSTAGE~1\main.c
 009E                   .dbsym e ip_to_Vout_Lookup _ip_to_Vout_Lookup A[158:158]kc
 009E           _ip_to_AFR_Lookup::
 009E BD00              .byte 189,0
 00A0 0001              .byte 0,1
 00A2 0102              .byte 1,2
 00A4 0202              .byte 2,2
 00A6 0203              .byte 2,3
 00A8 0303              .byte 3,3
 00AA 0404              .byte 4,4
 00AC 0405              .byte 4,5
 00AE 0505              .byte 5,5
 00B0 0506              .byte 5,6
 00B2 0607              .byte 6,7
 00B4 0707              .byte 7,7
 00B6 0708              .byte 7,8
 00B8 0809              .byte 8,9
 00BA 0909              .byte 9,9
 00BC 0910              .byte 9,16
 00BE 1011              .byte 16,17
 00C0 1111              .byte 17,17
 00C2 1212              .byte 18,18
 00C4 1213              .byte 18,19
 00C6 1313              .byte 19,19
 00C8 1314              .byte 19,20
 00CA 1415              .byte 20,21
 00CC 1515              .byte 21,21
 00CE 1616              .byte 22,22
 00D0 1617              .byte 22,23
 00D2 1717              .byte 23,23
 00D4 1818              .byte 24,24
 00D6 1819              .byte 24,25
 00D8 1920              .byte 25,32
 00DA 2020              .byte 32,32
 00DC 2121              .byte 33,33
 00DE 2222              .byte 34,34
 00E0 2223              .byte 34,35
 00E2 2324              .byte 35,36
 00E4 2424              .byte 36,36
 00E6 2525              .byte 37,37
 00E8 2526              .byte 37,38
 00EA 2627              .byte 38,39
 00EC 2727              .byte 39,39
 00EE 2828              .byte 40,40
 00F0 2929              .byte 41,41
 00F2 3030              .byte 48,48
 00F4 3131              .byte 49,49
 00F6 3132              .byte 49,50
 00F8 3233              .byte 50,51
 00FA 3334              .byte 51,52
 00FC 3435              .byte 52,53
 00FE 3535              .byte 53,53
 0100 3636              .byte 54,54
 0102 3737              .byte 55,55
 0104 3838              .byte 56,56
 0106 3839              .byte 56,57
 0108 4040              .byte 64,64
 010A 4041              .byte 64,'A
 010C 4242              .byte 'B,'B
 010E 4243              .byte 'B,'C
 0110 4444              .byte 'D,'D
 0112 4445              .byte 'D,'E
 0114 4546              .byte 'E,'F
 0116 4747              .byte 'G,'G
 0118 4849              .byte 'H,'I
 011A 5152              .byte 'Q,'R
 011C 5354              .byte 'S,'T
 011E 5556              .byte 'U,'V
 0120 5859              .byte 'X,'Y
 0122 6062              .byte 96,'b
 0124 6364              .byte 'c,'d
 0126 6667              .byte 'f,'g
 0128 6970              .byte 'i,'p
 012A 7173              .byte 'q,'s
 012C 7576              .byte 'u,'v
 012E 7779              .byte 'w,'y
 0130 8182              .byte 129,130
 0132 8485              .byte 132,133
 0134 8789              .byte 135,137
 0136 9193              .byte 145,147
 0138 9496              .byte 148,150
 013A 98AC              .byte 152,172
 013C                   .dbsym e ip_to_AFR_Lookup _ip_to_AFR_Lookup A[158:158]kc
                        .area data(ram, con, rel)
 0000                   .dbfile I:\PSOCDO~1\WBOOS_~2\DSTAGE~1\DSTAGE~1\main.c
 0000           _m_brightness::
 0000                   .blkb 1
                        .area idata(rom,lit)
 0000 0D                .byte 13
                        .area data(ram, con, rel)
 0001                   .dbfile I:\PSOCDO~1\WBOOS_~2\DSTAGE~1\DSTAGE~1\main.c
 0001                   .dbsym e m_brightness _m_brightness c
                        .area lit(rom, con, rel, lit)
 013C           _digitToSegment::
 013C 3F06              .byte 63,6
 013E 5B4F              .byte 91,'O
 0140 666D              .byte 'f,'m
 0142 7D07              .byte 125,7
 0144 7F6F              .byte 127,'o
 0146 3876              .byte 56,'v
 0148 5C10              .byte 92,16
 014A                   .dbsym e digitToSegment _digitToSegment A[14:14]kc
                        .area data(ram, con, rel)
 0001                   .dbfile I:\PSOCDO~1\WBOOS_~2\DSTAGE~1\DSTAGE~1\main.c
 0001           _Ri_Mid_Error_Sum::
 0001                   .blkb 2
                        .area idata(rom,lit)
 0001 0000              .word 0
                        .area data(ram, con, rel)
 0003                   .dbfile I:\PSOCDO~1\WBOOS_~2\DSTAGE~1\DSTAGE~1\main.c
 0003                   .dbsym e Ri_Mid_Error_Sum _Ri_Mid_Error_Sum I
 0003           _Ri_Delta_Error_Sum::
 0003                   .blkb 2
                        .area idata(rom,lit)
 0003 0000              .word 0
                        .area data(ram, con, rel)
 0005                   .dbfile I:\PSOCDO~1\WBOOS_~2\DSTAGE~1\DSTAGE~1\main.c
 0005                   .dbsym e Ri_Delta_Error_Sum _Ri_Delta_Error_Sum I
 0005           _Heatup_Heater_Output::
 0005                   .blkb 1
                        .area idata(rom,lit)
 0005 64                .byte 100
                        .area data(ram, con, rel)
 0006                   .dbfile I:\PSOCDO~1\WBOOS_~2\DSTAGE~1\DSTAGE~1\main.c
 0006                   .dbsym e Heatup_Heater_Output _Heatup_Heater_Output c
                        .area text(rom, con, rel)
 0000                   .dbfile I:\PSOCDO~1\WBOOS_~2\DSTAGE~1\DSTAGE~1\main.c
 0000                   .dbfunc e Heater_PID _Heater_PID fV
 0000           _Heater_PID::
 0000                   .dbline -1
 0000                   .dbline 302
 0000           ; // =========================================================================================
 0000           ; // === DStage WBOOS - SLC Free tribute =====================================================
 0000           ; // =========================================================================================
 0000           ; // This program is a heavily modified version of the 
 0000           ; // 14point7 SLC Free open wideband oxygen sensor controller
 0000           ; //
 0000           ; // Version history:
 0000           ; //            1.2.0 2025.02.02 - initial version
 0000           ; //            1.2.1 2026.02.19 - additional indications on the LED display
 0000           ; // 
 0000           ; // email: dstagegarage@gmail.com
 0000           ; // YT: www.youtube.com/DStageGarage
 0000           ; // GitHub: https://github.com/DStageGarage/WBOOS/
 0000           ; // =========================================================================================
 0000           ; 
 0000           ; //----------------------------------------------------------------------------
 0000           ; // C main line
 0000           ; //----------------------------------------------------------------------------
 0000           ; #include <m8c.h>        // part specific constants and macros
 0000           ; #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
 0000           ; extern BYTE ADC_Counter; //Variable Declared in ADCININT.asm
 0000           ; extern BYTE Ri_Max_x1; //Variable Declared in ADCININT.asm
 0000           ; extern BYTE Ri_Min_x1; //Variable Declared in ADCININT.asm
 0000           ; extern BYTE ip_x1; //Variable Declared in ADCININT.asm
 0000           ; extern BYTE ADC_IF; //Variable Declared in ADCININT.asm
 0000           ; extern BYTE Sleep_Counter; //Variable Declared in SleepTimerINT.asm
 0000           ; 
 0000           ; #define Vout_Lookup_Counter_Set 25
 0000           ; 
 0000           ; //============================================
 0000           ; // Configure system here
 0000           ; //============================================
 0000           ; // set how often display gets refreshed, 50 is a default value meaning roughly 50x2ms=100ms or 10 times per second
 0000           ; #define LCD_Counter_Set 50
 0000           ; 
 0000           ; // define output signal, Lin_Out (wide band) and NB_Out (narrow band) can be both present at once, NB_simple doesn't use intermediate value (it saves flash memory)
 0000           ; #define Lin_Out
 0000           ; #define NB_Out
 0000           ; //#define NB_simple_Out
 0000           ; 
 0000           ; // define display type and content following these guidlines:
 0000           ; //   - LCD Lmbda and AFR digits can be used at the same time but without Lambda/Temperature Graph
 0000           ; //   - LCD Lambda/Temperature Graph cannot be used at the same time
 0000           ; //   - LCD Temperature digits can be used together with Lambda/AFR digits
 0000           ; //   - LED and LCD cannot be used at the same time
 0000           ; //     - LED AFR and Lambda can be used at the same time switched with a pin but without heater dot and without dimmer and with simple NB outout (memory restrictios)
 0000           ; //     - LED AFR and Lambda can be used at the same time switched with a pin with heater do but without dimmer and without NB outout (memory restrictios)
 0000           ; //     - LED AFR and Lambda can be used at the same time switched with a pin without heater do but with dimmer and without NB outout (memory restrictios)
 0000           ; //   - comment out #define for unused options
 0000           ; // #define LCD_Lambda_Graph
 0000           ;  //#define LCD_AFR_digits
 0000           ; //#define LCD_Lambda_digits
 0000           ; //#define LCD_Temperature_Graph
 0000           ;  //#define LCD_Temperature_digits
 0000           ; //#define DStage_logo
 0000           ; #define LED_AFR
 0000           ; //#define LED_Lambda
 0000           ; #define LED_Dimmer
 0000           ; #define LED_Heater_dot
 0000           ; 
 0000           ; // Set brightness level for LED display
 0000           ; // 0: 7%; 1: 14%; 2: 29%; 3: 71%; 4: 79%; 5: 86%; 6: 93%; 7: 100%
 0000           ; #define LED_BR_LOW 2
 0000           ; #define LED_BR_HIGH 5
 0000           ; 
 0000           ; // Define port/pin for LED display controller TM1637
 0000           ; #define DIO_PORT 1
 0000           ; #define DIO_PIN 0
 0000           ; #define CLK_PORT 1
 0000           ; #define CLK_PIN 1
 0000           ; #define SWITCH_PORT 1
 0000           ; #define SWITCH_PIN 7
 0000           ; #define BRIGH_PORT 1
 0000           ; #define BRIGH_PIN 3
 0000           ; //============================================
 0000           ; 
 0000           ; #define LED_ON 0x08
 0000           ; 
 0000           ; #define SWPIN (1 << SWITCH_PIN)
 0000           ; #if SWITCH_PORT == 1
 0000           ;       #define SWPORT PRT1DR
 0000           ;       #define SWDM2 PRT1DM2
 0000           ;       #define SWDM1 PRT1DM1
 0000           ;       #define SWDM0 PRT1DM0
 0000           ; #elif SWITCH_PORT == 2
 0000           ;       #define SWPORT PRT2DR
 0000           ;       #define SWDM2 PRT2DM2
 0000           ;       #define SWDM1 PRT2DM1
 0000           ;       #define SWDM0 PRT2DM0
 0000           ; #else
 0000           ;       #define SWPORT PRT0DR
 0000           ;       #define SWDM2 PRT0DM2
 0000           ;       #define SWDM1 PRT0DM1
 0000           ;       #define SWDM0 PRT0DM0
 0000           ; #endif
 0000           ; 
 0000           ; #define BRPIN (1 << BRIGH_PIN)
 0000           ; #if BRIGH_PORT == 1
 0000           ;       #define BRPORT PRT1DR
 0000           ;       #define BRDM2 PRT1DM2
 0000           ;       #define BRDM1 PRT1DM1
 0000           ;       #define BRDM0 PRT1DM0
 0000           ; #elif BRIGH_PORT == 2
 0000           ;       #define BRPORT PRT2DR
 0000           ;       #define BRDM2 PRT2DM2
 0000           ;       #define BRDM1 PRT2DM1
 0000           ;       #define BRDM0 PRT2DM0
 0000           ; #else
 0000           ;       #define BRPORT PRT0DR
 0000           ;       #define BRDM2 PRT0DM2
 0000           ;       #define BRDM1 PRT0DM1
 0000           ;       #define BRDM0 PRT0DM0
 0000           ; #endif
 0000           ; 
 0000           ; //#define PID_Tune
 0000           ; #define Ri_Filter_Strength 4
 0000           ; #define ip_Filter_Strength 4
 0000           ; 
 0000           ; #ifdef PID_Tune
 0000           ;       INT Ri_Mid_Target= 286;//271; //
 0000           ;       INT Ia_PID_Kp = 25; //35;
 0000           ;       INT Ia_PID_Ki = 4; //8;
 0000           ;       INT Ia_Output_Bias = 256;
 0000           ;       INT Ri_Delta_Target=143; //PID Target peak to peak Voltage of Nermest Cell
 0000           ;       INT Heater_PID_Kp =-72;
 0000           ;       INT Heater_PID_Ki =-4;
 0000           ;       INT Heater_PID_Output_Bias =128;
 0000           ; #else
 0000           ;       #define Ri_Mid_Target 286 //271 //256+14.769 = 2.53v = 2.08v(VGND) + 0.45v, PID Target Voltage of Nermest Cell
 0000           ;       #define Ia_PID_Kp 25
 0000           ;       #define Ia_PID_Ki 4
 0000           ;       #define Ia_Output_Bias 256
 0000           ;       #define Ri_Delta_Target 143 //PID Target peak to peak Voltage of Nermest Cell
 0000           ;       #define Heater_PID_Kp -72
 0000           ;       #define Heater_PID_Ki -4
 0000           ;       #define Heater_PID_Output_Bias 128
 0000           ; #endif
 0000           ; 
 0000           ; #ifdef Lin_Out
 0000           ;       #define ip_to_Vout_Lookup_Start 135
 0000           ;       #define ip_to_Vout_Lookup_Size 158
 0000           ;       const BYTE ip_to_Vout_Lookup[ip_to_Vout_Lookup_Size] = {0,1,1,2,3,4,4,5,6,7,8,8,9,10,11,12,12,13,14,15,16,17,17,18,19,20,21,22,22,23,24,25,26,27,27,28,29,30,31,32,33,34,34,35,36,37,38,39,40,41,42,43,44,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,76,77,78,79,80,81,82,83,84,86,87,88,89,90,91,92,94,95,96,97,98,100,101,102,103,105,106,107,108,110,111,112,113,115,116,117,119,120,123,126,129,132,135,138,141,144,147,151,154,157,161,164,168,171,175,178,182,186,190,194,197,201,206,210,214,218,222,227,231,236,240,245,250,255}; 
 0000           ; #endif
 0000           ; 
 0000           ; #ifdef LCD_Lambda_Graph
 0000           ;       #define ip_to_Lambda_Lookup_Start 135
 0000           ;       #define ip_to_Lambda_Lookup_Size 158
 0000           ;       const BYTE ip_to_Graph_Lookup[ip_to_Lambda_Lookup_Size]={1,8,8,9,9,9,9,9,10,10,10,10,10,11,11,11,11,12,12,12,12,12,13,13,13,13,14,14,14,14,14,15,15,15,15,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,22,22,22,22,23,23,23,23,24,24,24,25,25,25,25,26,26,26,26,27,27,27,28,28,28,28,29,29,29,30,30,30,31,31,31,31,32,32,32,33,33,33,34,34,34,35,35,35,36,36,36,37,37,37,38,38,38,39,39,39,40,40,41,42,42,43,44,45,46,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,70,71,72,73,75,80};
 0000           ;                                                                                                // lambda = 0.68  0.69      0.70           0.71        0.72           0.73        0.74           0.75        0.76           0.77        0.78        0.79        0.8         0.81        0.82           0.83     0.84     0.85        0.86        0.87     0.88        0.89     0.90     0.91        0.92     0.93     0.94     0.95     0.96     0.97     0.98     0.99     1.00
 0000           ;                                                                                                // AFR    = 10.0  10.14     10.3           10.44       10.58          10.73       10.88          11.03
 0000           ; #endif
 0000           ; 
 0000           ; #if defined LCD_AFR_digits 
 0000           ;       #define ip_to_AFR_Lookup_Start 135
 0000           ;       #define ip_to_AFR_Lookup_Size 158
 0000           ;       const BYTE ip_to_AFR_Lookup[ip_to_AFR_Lookup_Size] = {0xFC,0x00,0x00,0x01,0x01,0x02,0x02,0x02,0x02,0x03,0x03,0x03,0x04,0x04,0x04,0x05,0x05,0x05,0x05,0x06,0x06,0x07,0x07,0x07,0x07,0x08,0x08,0x09,0x09,0x09,0x09,
 0000           ;                                                                                                                 0x10,0x10,0x11,0x11,0x11,0x12,0x12,0x12,0x13,0x13,0x13,0x13,0x14,0x14,0x15,0x15,0x15,0x16,0x16,0x16,0x17,0x17,0x17,0x18,0x18,0x18,0x19,0x19,
 0000           ;                                                                                                                 0x20,0x20,0x20,0x21,0x21,0x22,0x22,0x22,0x23,0x23,0x24,0x24,0x24,0x25,0x25,0x25,0x26,0x26,0x27,0x27,0x27,0x28,0x28,0x29,0x29,
 0000           ;                                                                                                                 0x30,0x30,0x31,0x31,0x31,0x32,0x32,0x33,0x33,0x34,0x34,0x35,0x35,0x35,0x36,0x36,0x37,0x37,0x38,0x38,0x38,0x39,
 0000           ;                                                                                                                 0x40,0x40,0x40,0x41,0x42,0x42,0x42,0x43,0x44,0x44,0x44,0x45,0x45,0x46,0x47,0x47,0x48,0x49,
 0000           ;                                                                                                                 0x51,0x52,0x53,0x54,0x55,0x56,0x58,0x59,
 0000           ;                                                                                                                 0x60,0x62,0x63,0x64,0x66,0x67,0x69,
 0000           ;                                                                                                                 0x70,0x71,0x73,0x75,0x76,0x77,0x79,
 0000           ;                                                                                                                 0x81,0x82,0x84,0x85,0x87,0x89,
 0000           ;                                                                                                                 0x91,0x93,0x94,0x96,0x98,
 0000           ;                                                                                                                 0xFE}; 
 0000           ; #endif
 0000           ; 
 0000           ; #if defined LED_AFR 
 0000           ;       #define ip_to_AFR_Lookup_Start 135
 0000           ;       #define ip_to_AFR_Lookup_Size 158
 0000           ;       const BYTE ip_to_AFR_Lookup[ip_to_AFR_Lookup_Size] = {0xBD,0x00,0x00,0x01,0x01,0x02,0x02,0x02,0x02,0x03,0x03,0x03,0x04,0x04,0x04,0x05,0x05,0x05,0x05,0x06,0x06,0x07,0x07,0x07,0x07,0x08,0x08,0x09,0x09,0x09,0x09,
 0000           ;                                                                                                                 0x10,0x10,0x11,0x11,0x11,0x12,0x12,0x12,0x13,0x13,0x13,0x13,0x14,0x14,0x15,0x15,0x15,0x16,0x16,0x16,0x17,0x17,0x17,0x18,0x18,0x18,0x19,0x19,
 0000           ;                                                                                                                 0x20,0x20,0x20,0x21,0x21,0x22,0x22,0x22,0x23,0x23,0x24,0x24,0x24,0x25,0x25,0x25,0x26,0x26,0x27,0x27,0x27,0x28,0x28,0x29,0x29,
 0000           ;                                                                                                                 0x30,0x30,0x31,0x31,0x31,0x32,0x32,0x33,0x33,0x34,0x34,0x35,0x35,0x35,0x36,0x36,0x37,0x37,0x38,0x38,0x38,0x39,
 0000           ;                                                                                                                 0x40,0x40,0x40,0x41,0x42,0x42,0x42,0x43,0x44,0x44,0x44,0x45,0x45,0x46,0x47,0x47,0x48,0x49,
 0000           ;                                                                                                                 0x51,0x52,0x53,0x54,0x55,0x56,0x58,0x59,
 0000           ;                                                                                                                 0x60,0x62,0x63,0x64,0x66,0x67,0x69,
 0000           ;                                                                                                                 0x70,0x71,0x73,0x75,0x76,0x77,0x79,
 0000           ;                                                                                                                 0x81,0x82,0x84,0x85,0x87,0x89,
 0000           ;                                                                                                                 0x91,0x93,0x94,0x96,0x98,
 0000           ;                                                                                                                 0xAC}; 
 0000           ; #endif
 0000           ; 
 0000           ; #if defined LCD_Lambda_digits
 0000           ;       #define ip_to_LambdaD_Lookup_Start 135
 0000           ;       #define ip_to_LambdaD_Lookup_Size 158
 0000           ;       const BYTE ip_to_Lambda_Lookup[ip_to_LambdaD_Lookup_Size]= {0xFC,0x68,0x68,0x69,0x69,0x69,0x69,0x69,
 0000           ;                                                                                                                               0x70,0x70,0x70,0x70,0x70,0x71,0x71,0x71,0x71,0x72,0x72,0x72,0x72,0x72,0x73,0x73,0x73,0x73,0x74,0x74,0x74,0x74,0x74,0x75,0x75,0x75,0x75,0x76,0x76,0x76,0x76,0x76,0x77,0x77,0x77,0x77,0x78,0x78,0x78,0x78,0x79,0x79,0x79,0x79,
 0000           ;                                                                                                                               0x80,0x80,0x80,0x80,0x81,0x81,0x81,0x81,0x82,0x82,0x82,0x82,0x83,0x83,0x83,0x83,0x84,0x84,0x84,0x85,0x85,0x85,0x85,0x86,0x86,0x86,0x86,0x87,0x87,0x87,0x88,0x88,0x88,0x88,0x89,0x89,0x89,
 0000           ;                                                                                                                               0x90,0x90,0x90,0x91,0x91,0x91,0x91,0x92,0x92,0x92,0x93,0x93,0x93,0x94,0x94,0x94,0x95,0x95,0x95,0x96,0x96,0x96,0x97,0x97,0x97,0x98,0x98,0x98,0x99,0x99,0x99,
 0000           ;                                                                                                                               0x00,0x00,0x01,0x02,0x02,0x03,0x04,0x05,0x06,0x06,0x07,0x08,0x09,
 0000           ;                                                                                                                               0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,
 0000           ;                                                                                                                               0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,
 0000           ;                                                                                                                               0x30,0x31,0x32,0x33,0x35,
 0000           ;                                                                                                                               0xFE};
 0000           ; #endif
 0000           ; 
 0000           ; #if defined LED_Lambda
 0000           ;       #define ip_to_LambdaD_Lookup_Start 135
 0000           ;       #define ip_to_LambdaD_Lookup_Size 158
 0000           ;       const BYTE ip_to_Lambda_Lookup[ip_to_LambdaD_Lookup_Size]= {0xBD,0x68,0x68,0x69,0x69,0x69,0x69,0x69,
 0000           ;                                                                                                                               0x70,0x70,0x70,0x70,0x70,0x71,0x71,0x71,0x71,0x72,0x72,0x72,0x72,0x72,0x73,0x73,0x73,0x73,0x74,0x74,0x74,0x74,0x74,0x75,0x75,0x75,0x75,0x76,0x76,0x76,0x76,0x76,0x77,0x77,0x77,0x77,0x78,0x78,0x78,0x78,0x79,0x79,0x79,0x79,
 0000           ;                                                                                                                               0x80,0x80,0x80,0x80,0x81,0x81,0x81,0x81,0x82,0x82,0x82,0x82,0x83,0x83,0x83,0x83,0x84,0x84,0x84,0x85,0x85,0x85,0x85,0x86,0x86,0x86,0x86,0x87,0x87,0x87,0x88,0x88,0x88,0x88,0x89,0x89,0x89,
 0000           ;                                                                                                                               0x90,0x90,0x90,0x91,0x91,0x91,0x91,0x92,0x92,0x92,0x93,0x93,0x93,0x94,0x94,0x94,0x95,0x95,0x95,0x96,0x96,0x96,0x97,0x97,0x97,0x98,0x98,0x98,0x99,0x99,0x99,
 0000           ;                                                                                                                               0x00,0x00,0x01,0x02,0x02,0x03,0x04,0x05,0x06,0x06,0x07,0x08,0x09,
 0000           ;                                                                                                                               0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,
 0000           ;                                                                                                                               0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,
 0000           ;                                                                                                                               0x30,0x31,0x32,0x33,0x35,
 0000           ;                                                                                                                               0xAC};
 0000           ; #endif
 0000           ; 
 0000           ; #ifdef LCD_Temperature_Graph
 0000           ;       #define Ri_Delta_to_Temperature_C_Start 113
 0000           ;       #define Ri_Delta_to_Temperature_C_Size 75
 0000           ;       const BYTE Ri_Delta_to_Graph[Ri_Delta_to_Temperature_C_Size]={80,78,77,75,74,73,71,70,68,67,65,64,63,61,60,59,58,56,55,54,52,51,50,49,48,46,45,44,43,42,41,40,39,37,36,35,34,33,32,31,30,29,28,27,26,25,24,23,22,21,20,19,18,18,17,16,15,14,13,12,11,11,10,9,8,7,6,5,5,4,3,2,1,1,0};
 0000           ; #endif
 0000           ; 
 0000           ; #ifdef LCD_Temperature_digits
 0000           ;       #define Ri_Delta_to_Temperature_C_dig_Start 113
 0000           ;       #define Ri_Delta_to_Temperature_C_dig_Size 75
 0000           ;       const BYTE Ri_Delta_to_dig[Ri_Delta_to_Temperature_C_dig_Size]={0xFE,
 0000           ;                                                                                                                                       0x18,0x17,0x15,0x14,0x13,0x11,0x10,
 0000           ;                                                                                                                                       0x08,0x07,0x05,0x04,0x03,0x01,0x00,
 0000           ;                                                                                                                                       0x99,0x98,0x96,0x95,0x94,0x92,0x91,0x90,
 0000           ;                                                                                                                                       0x89,0x88,0x86,0x85,0x84,0x83,0x82,0x81,0x80,
 0000           ;                                                                                                                                       0x79,0x77,0x76,0x75,0x74,0x73,0x72,0x71,0x70,
 0000           ;                                                                                                                                       0x69,0x68,0x67,0x66,0x65,0x64,0x63,0x62,0x61,0x60,
 0000           ;                                                                                                                                       0x59,0x58,0x58,0x57,0x56,0x55,0x54,0x53,0x52,0x51,0x51,0x50,
 0000           ;                                                                                                                                       0x49,0x48,0x47,0x46,0x45,0x45,0x44,0x43,0x42,0x41,0x40,0xFC,};
 0000           ; #endif
 0000           ; 
 0000           ; #if defined LED_AFR || defined LED_Lambda
 0000           ;       void TM1637_init(void);
 0000           ;       void TM1637_setBrightness(BYTE, BYTE);
 0000           ;       void TM1637_setSegments(BYTE*, BYTE, BYTE);
 0000           ;       void TM1637_clear(void);
 0000           ;       void TM1637_showNumberDec(int, BYTE, BYTE, BYTE);
 0000           ;       void TM1637_showNumberDecEx(int, BYTE, BYTE, BYTE, BYTE);
 0000           ;       void TM1637_showNumberHexEx(unsigned int, BYTE, BYTE, BYTE, BYTE);
 0000           ;       void TM1637_showNumberBaseEx(BYTE, unsigned int, BYTE, BYTE, BYTE, BYTE);
 0000           ;       void TM1637_start(void);
 0000           ;       void TM1637_stop(void);
 0000           ;       BYTE TM1637_writeByte(BYTE);
 0000           ;       void TM1637_showDots(BYTE, BYTE*);
 0000           ;       BYTE TM1637_encodeDigit(BYTE);
 0000           ;       
 0000           ;       BYTE m_brightness = LED_BR_HIGH | 0x08;
 0000           ;       
 0000           ;       //      A
 0000           ;       //     ---
 0000           ;       //  F |   | B
 0000           ;       //     -G-
 0000           ;       //  E |   | C
 0000           ;       //     ---
 0000           ;       //      D
 0000           ;       const BYTE digitToSegment[] = {
 0000           ;       // XGFEDCBA
 0000           ;       0b00111111,    // 0
 0000           ;       0b00000110,    // 1
 0000           ;       0b01011011,    // 2
 0000           ;       0b01001111,    // 3
 0000           ;       0b01100110,    // 4
 0000           ;       0b01101101,    // 5
 0000           ;       0b01111101,    // 6
 0000           ;       0b00000111,    // 7
 0000           ;       0b01111111,    // 8
 0000           ;       0b01101111,    // 9
 0000           ;       0b00111000,    // L (0xA)
 0000           ;       0b01110110,    // H (0xB)
 0000           ;       0b01011100,    // o (0xC)
 0000           ;       0b00010000,    // i (0xD)
 0000           ;       //0b01111001,    // E
 0000           ;       //0b01110001     // F
 0000           ;       //0b01110111,    // A
 0000           ;       //0b01111100,    // b
 0000           ;       //0b00111001,    // C
 0000           ;       //0b01011110,    // d
 0000           ;       //0b01111001,    // E
 0000           ;       //0b01110001     // F
 0000           ;       };
 0000           ; #endif
 0000           ; 
 0000           ; INT Ri_Mid_Error_Sum=0;
 0000           ; INT Ri_Mid;
 0000           ; INT Ri_Delta_Error_Sum=0;
 0000           ; INT Ri_Delta;
 0000           ; #define Ia_PID_Counter_Set 1
 0000           ; #define Heatup_Counter_Set 100
 0000           ; #define Heater_PID_Counter_Set 25
 0000           ; BYTE Heatup_Heater_Output=100;
 0000           ; 
 0000           ; INT Ri_Delta_Error;
 0000           ; INT Heater_Output;
 0000           ; INT Heater_Pout;
 0000           ; INT Heater_Iout;
 0000           ; 
 0000           ; //PID Controller, Input is Ri_Delta (The Peak to peak voltage on the Vs Port of the sensor) output is PWM8_Heater, PWM8_Heater is controlled such that Ri_Delta is maintained at 80 (80 =750C)
 0000           ; //Only a PI controller is used as adding the D term does not effect performance 
 0000           ; //Everything is inflated by a factor of 4 so that floating point is avioded
 0000           ; void Heater_PID(void) // Ned to run this when counter >50
 0000           ; {
 0000                   .dbline 304
 0000           ; 
 0000           ;       Ri_Delta_Error=Ri_Delta_Target-Ri_Delta;
 0000 508F              mov A,-113
 0002 121C              sub A,[_Ri_Delta+1]
 0004 531A              mov [_Ri_Delta_Error+1],A
 0006 5000              mov A,0
 0008 1A1B              sbb A,[_Ri_Delta]
 000A 5319              mov [_Ri_Delta_Error],A
 000C                   .dbline 306
 000C           ;       //Put limits on Error so PID does not go Fubar, and also so that the worst case multiplication does not overflow
 000C           ;       if (Ri_Delta_Error>(-127*16/Heater_PID_Kp))
 000C 501C              mov A,28
 000E 121A              sub A,[_Ri_Delta_Error+1]
 0010 5119              mov A,[_Ri_Delta_Error]
 0012 3180              xor A,-128
 0014 5300              mov [__rX],A
 0016 5080              mov A,(0 ^ 0x80)
 0018 1A00              sbb A,[__rX]
 001A D007              jnc L2
 001C           X0:
 001C                   .dbline 308
 001C           ;       {
 001C           ;               Ri_Delta_Error=(-127*16/Heater_PID_Kp); // -> 28, used to be 56...
 001C                   .dbline 308
 001C 551A1C            mov [_Ri_Delta_Error+1],28
 001F 551900            mov [_Ri_Delta_Error],0
 0022                   .dbline 309
 0022           ;       }
 0022           L2:
 0022                   .dbline 310
 0022           ;       if (Ri_Delta_Error<(127*16/Heater_PID_Kp))
 0022 511A              mov A,[_Ri_Delta_Error+1]
 0024 11E4              sub A,-28
 0026 5119              mov A,[_Ri_Delta_Error]
 0028 3180              xor A,-128
 002A 197F              sbb A,(-1 ^ 0x80)
 002C D007              jnc L4
 002E           X1:
 002E                   .dbline 312
 002E           ;       {
 002E           ;               Ri_Delta_Error=(127*16/Heater_PID_Kp); // -> -28, used to be -56...
 002E                   .dbline 312
 002E 551AE4            mov [_Ri_Delta_Error+1],-28
 0031 5519FF            mov [_Ri_Delta_Error],-1
 0034                   .dbline 313
 0034           ;       }
 0034           L4:
 0034                   .dbline 314
 0034           ;       Heater_Pout=(Heater_PID_Kp*Ri_Delta_Error)/16;
 0034 5F001A            mov [__r1],[_Ri_Delta_Error+1]
 0037 5F0019            mov [__r0],[_Ri_Delta_Error]
 003A 5500B8            mov [__r3],-72
 003D 5500FF            mov [__r2],-1
 0040 550000            mov [__rX],0
 0043 550000            mov [__rY],0
 0046           X2:
 0046 3C0000            cmp [__r2],0
 0049 B006              jnz X5
 004B 3C0000            cmp [__r3],0
 004E A017              jz X4
 0050           X5:
 0050 70FB              and F,-5
 0052 6E00              rrc [__r2]
 0054 6E00              rrc [__r3]
 0056 D009              jnc X3
 0058 5100              mov A,[__r1]
 005A 0400              add [__rX],A
 005C 5100              mov A,[__r0]
 005E 0C00              adc [__rY],A
 0060           X3:
 0060 6500              asl [__r1]
 0062 6B00              rlc [__r0]
 0064 8FE1              jmp X2
 0066           X4:
 0066 5F0000            mov [__r1],[__rX]
 0069 5F0000            mov [__r0],[__rY]
 006C 5000              mov A,0
 006E 08                push A
 006F 5010              mov A,16
 0071 08                push A
 0072 5100              mov A,[__r0]
 0074 08                push A
 0075 5100              mov A,[__r1]
 0077 08                push A
 0078 7C0000            xcall __divmod_16X16_16
 007B 18                pop A
 007C 5316              mov [_Heater_Pout+1],A
 007E 18                pop A
 007F 5315              mov [_Heater_Pout],A
 0081 38FE              add SP,-2
 0083                   .dbline 315
 0083           ;       Ri_Delta_Error_Sum=Ri_Delta_Error_Sum+Ri_Delta_Error;
 0083 511A              mov A,[_Ri_Delta_Error+1]
 0085 0404              add [_Ri_Delta_Error_Sum+1],A
 0087 5119              mov A,[_Ri_Delta_Error]
 0089 0C03              adc [_Ri_Delta_Error_Sum],A
 008B                   .dbline 324
 008B           ;       //If the sensor is too hot, then disreguard the Integratal contribution and just use the proportional to quickly correct the sensor temperature
 008B           ;       /*
 008B           ;       if((Ri_Delta<60)&&(Ri_Delta_Error_Sum>0))
 008B           ;       {
 008B           ;               Ri_Delta_Error_Sum=0;
 008B           ;       }
 008B           ;       */
 008B           ;       //Put limits on Error so PID does not go Fubar, and also so that the worst case multiplication does not overflow
 008B           ;       if (Ri_Delta_Error_Sum>(-127*16/Heater_PID_Ki))
 008B 50FC              mov A,-4
 008D 1204              sub A,[_Ri_Delta_Error_Sum+1]
 008F 5103              mov A,[_Ri_Delta_Error_Sum]
 0091 3180              xor A,-128
 0093 5300              mov [__rX],A
 0095 5081              mov A,(1 ^ 0x80)
 0097 1A00              sbb A,[__rX]
 0099 D007              jnc L6
 009B           X6:
 009B                   .dbline 326
 009B           ;       {
 009B           ;               Ri_Delta_Error_Sum=(-127*16/Heater_PID_Ki); // -> 508, used to be 1024...
 009B                   .dbline 326
 009B 5504FC            mov [_Ri_Delta_Error_Sum+1],-4
 009E 550301            mov [_Ri_Delta_Error_Sum],1
 00A1                   .dbline 327
 00A1           ;       }
 00A1           L6:
 00A1                   .dbline 328
 00A1           ;       if (Ri_Delta_Error_Sum<(127*16/Heater_PID_Ki))
 00A1 5104              mov A,[_Ri_Delta_Error_Sum+1]
 00A3 1104              sub A,4
 00A5 5103              mov A,[_Ri_Delta_Error_Sum]
 00A7 3180              xor A,-128
 00A9 197E              sbb A,(-2 ^ 0x80)
 00AB D007              jnc L8
 00AD           X7:
 00AD                   .dbline 330
 00AD           ;       {
 00AD           ;               Ri_Delta_Error_Sum=(127*16/Heater_PID_Ki); // -> -508, used to be -1024...
 00AD                   .dbline 330
 00AD 550404            mov [_Ri_Delta_Error_Sum+1],4
 00B0 5503FE            mov [_Ri_Delta_Error_Sum],-2
 00B3                   .dbline 331
 00B3           ;       }
 00B3           L8:
 00B3                   .dbline 332
 00B3           ;       Heater_Iout=(Heater_PID_Ki*Ri_Delta_Error_Sum)/16;
 00B3 5F0004            mov [__r1],[_Ri_Delta_Error_Sum+1]
 00B6 5F0003            mov [__r0],[_Ri_Delta_Error_Sum]
 00B9 5500FC            mov [__r3],-4
 00BC 5500FF            mov [__r2],-1
 00BF 550000            mov [__rX],0
 00C2 550000            mov [__rY],0
 00C5           X8:
 00C5 3C0000            cmp [__r2],0
 00C8 B006              jnz X11
 00CA 3C0000            cmp [__r3],0
 00CD A017              jz X10
 00CF           X11:
 00CF 70FB              and F,-5
 00D1 6E00              rrc [__r2]
 00D3 6E00              rrc [__r3]
 00D5 D009              jnc X9
 00D7 5100              mov A,[__r1]
 00D9 0400              add [__rX],A
 00DB 5100              mov A,[__r0]
 00DD 0C00              adc [__rY],A
 00DF           X9:
 00DF 6500              asl [__r1]
 00E1 6B00              rlc [__r0]
 00E3 8FE1              jmp X8
 00E5           X10:
 00E5 5F0000            mov [__r1],[__rX]
 00E8 5F0000            mov [__r0],[__rY]
 00EB 5000              mov A,0
 00ED 08                push A
 00EE 5010              mov A,16
 00F0 08                push A
 00F1 5100              mov A,[__r0]
 00F3 08                push A
 00F4 5100              mov A,[__r1]
 00F6 08                push A
 00F7 7C0000            xcall __divmod_16X16_16
 00FA 18                pop A
 00FB 5314              mov [_Heater_Iout+1],A
 00FD 18                pop A
 00FE 5313              mov [_Heater_Iout],A
 0100 38FE              add SP,-2
 0102                   .dbline 333
 0102           ;       if (Heatup_Heater_Output<255) // if Heatup_Heater_Output is < 255 that means the unit just turned on and to give control to the heatup routine
 0102 3C05FF            cmp [_Heatup_Heater_Output],-1
 0105 D009              jnc L10
 0107           X12:
 0107                   .dbline 335
 0107           ;       {
 0107           ;               Heater_Output=Heatup_Heater_Output;     
 0107                   .dbline 335
 0107 5F1805            mov [_Heater_Output+1],[_Heatup_Heater_Output]
 010A 551700            mov [_Heater_Output],0
 010D                   .dbline 336
 010D           ;       }
 010D 8019              xjmp L11
 010F           L10:
 010F                   .dbline 338
 010F           ;       else
 010F           ;       {       
 010F                   .dbline 339
 010F           ;               Heater_Output=Heater_PID_Output_Bias+Heater_Pout+Heater_Iout;                   
 010F 5116              mov A,[_Heater_Pout+1]
 0111 0180              add A,-128
 0113 5300              mov [__r1],A
 0115 5115              mov A,[_Heater_Pout]
 0117 0900              adc A,0
 0119 5300              mov [__r0],A
 011B 5100              mov A,[__r1]
 011D 0214              add A,[_Heater_Iout+1]
 011F 5318              mov [_Heater_Output+1],A
 0121 5100              mov A,[__r0]
 0123 0A13              adc A,[_Heater_Iout]
 0125 5317              mov [_Heater_Output],A
 0127                   .dbline 340
 0127           ;       }
 0127           L11:
 0127                   .dbline 342
 0127           ;       //Heater_Output=Heater_PID_Output_Bias+Heater_Pout+Heater_Iout; 
 0127           ;       if (Heater_Output<0)
 0127 5118              mov A,[_Heater_Output+1]
 0129 1100              sub A,0
 012B 5117              mov A,[_Heater_Output]
 012D 3180              xor A,-128
 012F 1980              sbb A,(0 ^ 0x80)
 0131 D007              jnc L12
 0133           X13:
 0133                   .dbline 344
 0133           ;       {
 0133           ;               Heater_Output=0;
 0133                   .dbline 344
 0133 551800            mov [_Heater_Output+1],0
 0136 551700            mov [_Heater_Output],0
 0139                   .dbline 345
 0139           ;       }
 0139           L12:
 0139                   .dbline 346
 0139           ;       if (Heater_Output>255)
 0139 50FF              mov A,-1
 013B 1218              sub A,[_Heater_Output+1]
 013D 5117              mov A,[_Heater_Output]
 013F 3180              xor A,-128
 0141 5300              mov [__rX],A
 0143 5080              mov A,(0 ^ 0x80)
 0145 1A00              sbb A,[__rX]
 0147 D007              jnc L14
 0149           X14:
 0149                   .dbline 348
 0149           ;       {
 0149           ;               Heater_Output=255;
 0149                   .dbline 348
 0149 5518FF            mov [_Heater_Output+1],-1
 014C 551700            mov [_Heater_Output],0
 014F                   .dbline 349
 014F           ;       }
 014F           L14:
 014F                   .dbline 352
 014F           ; 
 014F           ; 
 014F           ;       PWM8_Heater_WritePulseWidth(Heater_Output);
 014F 5F0018            mov [__r0],[_Heater_Output+1]
 0152 10                push X
 0153 5100              mov A,[__r0]
 0155 7C0000            xcall _PWM8_Heater_WritePulseWidth
 0158 20                pop X
 0159                   .dbline -2
 0159           L1:
 0159                   .dbline 0 ; func end
 0159 7F                ret
 015A                   .dbend
 015A                   .dbfunc e Ia_PID _Ia_PID fV
 015A           _Ia_PID::
 015A                   .dbline -1
 015A                   .dbline 364
 015A           ;       //PWM8_Heater_WritePulseWidth(200);
 015A           ; }
 015A           ; 
 015A           ; INT Ri_Mid_Error;
 015A           ; INT Ia_Output;
 015A           ; INT Ia_Pout;
 015A           ; INT Ia_Iout;
 015A           ; //PID Controller, Input is Ri_Mid (The average voltage on the Vs Port of the sensor) output is DAC9_Ia, DAC9_Ia sink/sources current to the Sensor pump cell such that Ri_Mid is is the same voltage as Vref
 015A           ; //Only a PI controller is used as adding the D term does not effect performance 
 015A           ; //Everything is inflated by a factor of 4 so that floating point is avioded
 015A           ; void Ia_PID(void)
 015A           ; {
 015A                   .dbline 367
 015A           ; 
 015A           ; 
 015A           ;       Ri_Mid_Error=Ri_Mid_Target-Ri_Mid;
 015A 501E              mov A,30
 015C 121E              sub A,[_Ri_Mid+1]
 015E 5312              mov [_Ri_Mid_Error+1],A
 0160 5001              mov A,1
 0162 1A1D              sbb A,[_Ri_Mid]
 0164 5311              mov [_Ri_Mid_Error],A
 0166                   .dbline 369
 0166           ;       //Put limits on Error so PID does not go Fubar, and also so that the worst case multiplication does not overflow
 0166           ;       if (Ri_Mid_Error>(255*16/Ia_PID_Kp))
 0166 50A3              mov A,-93
 0168 1212              sub A,[_Ri_Mid_Error+1]
 016A 5111              mov A,[_Ri_Mid_Error]
 016C 3180              xor A,-128
 016E 5300              mov [__rX],A
 0170 5080              mov A,(0 ^ 0x80)
 0172 1A00              sbb A,[__rX]
 0174 D007              jnc L17
 0176           X15:
 0176                   .dbline 371
 0176           ;       {
 0176           ;               Ri_Mid_Error=(255*16/Ia_PID_Kp); // 163
 0176                   .dbline 371
 0176 5512A3            mov [_Ri_Mid_Error+1],-93
 0179 551100            mov [_Ri_Mid_Error],0
 017C                   .dbline 372
 017C           ;       }
 017C           L17:
 017C                   .dbline 373
 017C           ;       if (Ri_Mid_Error<(-255*16/Ia_PID_Kp))
 017C 5112              mov A,[_Ri_Mid_Error+1]
 017E 115D              sub A,93
 0180 5111              mov A,[_Ri_Mid_Error]
 0182 3180              xor A,-128
 0184 197F              sbb A,(-1 ^ 0x80)
 0186 D007              jnc L19
 0188           X16:
 0188                   .dbline 375
 0188           ;       {
 0188           ;               Ri_Mid_Error=(-255*16/Ia_PID_Kp); // -163
 0188                   .dbline 375
 0188 55125D            mov [_Ri_Mid_Error+1],93
 018B 5511FF            mov [_Ri_Mid_Error],-1
 018E                   .dbline 376
 018E           ;       }
 018E           L19:
 018E                   .dbline 377
 018E           ;       Ia_Pout=(Ia_PID_Kp*Ri_Mid_Error)/16;
 018E 5F0012            mov [__r1],[_Ri_Mid_Error+1]
 0191 5F0011            mov [__r0],[_Ri_Mid_Error]
 0194 550019            mov [__r3],25
 0197 550000            mov [__r2],0
 019A 550000            mov [__rX],0
 019D 550000            mov [__rY],0
 01A0           X17:
 01A0 3C0000            cmp [__r2],0
 01A3 B006              jnz X20
 01A5 3C0000            cmp [__r3],0
 01A8 A017              jz X19
 01AA           X20:
 01AA 70FB              and F,-5
 01AC 6E00              rrc [__r2]
 01AE 6E00              rrc [__r3]
 01B0 D009              jnc X18
 01B2 5100              mov A,[__r1]
 01B4 0400              add [__rX],A
 01B6 5100              mov A,[__r0]
 01B8 0C00              adc [__rY],A
 01BA           X18:
 01BA 6500              asl [__r1]
 01BC 6B00              rlc [__r0]
 01BE 8FE1              jmp X17
 01C0           X19:
 01C0 5F0000            mov [__r1],[__rX]
 01C3 5F0000            mov [__r0],[__rY]
 01C6 5000              mov A,0
 01C8 08                push A
 01C9 5010              mov A,16
 01CB 08                push A
 01CC 5100              mov A,[__r0]
 01CE 08                push A
 01CF 5100              mov A,[__r1]
 01D1 08                push A
 01D2 7C0000            xcall __divmod_16X16_16
 01D5 18                pop A
 01D6 530E              mov [_Ia_Pout+1],A
 01D8 18                pop A
 01D9 530D              mov [_Ia_Pout],A
 01DB 38FE              add SP,-2
 01DD                   .dbline 378
 01DD           ;       Ri_Mid_Error_Sum=Ri_Mid_Error_Sum+Ri_Mid_Error;
 01DD 5112              mov A,[_Ri_Mid_Error+1]
 01DF 0402              add [_Ri_Mid_Error_Sum+1],A
 01E1 5111              mov A,[_Ri_Mid_Error]
 01E3 0C01              adc [_Ri_Mid_Error_Sum],A
 01E5                   .dbline 380
 01E5           ;       //Put limits on Error so PID does not go Fubar, and also so that the worst case multiplication does not overflow
 01E5           ;       if (Ri_Mid_Error_Sum>(255*16/Ia_PID_Ki))
 01E5 50FC              mov A,-4
 01E7 1202              sub A,[_Ri_Mid_Error_Sum+1]
 01E9 5101              mov A,[_Ri_Mid_Error_Sum]
 01EB 3180              xor A,-128
 01ED 5300              mov [__rX],A
 01EF 5083              mov A,(3 ^ 0x80)
 01F1 1A00              sbb A,[__rX]
 01F3 D007              jnc L21
 01F5           X21:
 01F5                   .dbline 382
 01F5           ;       {
 01F5           ;               Ri_Mid_Error_Sum=(255*16/Ia_PID_Ki); // 1020
 01F5                   .dbline 382
 01F5 5502FC            mov [_Ri_Mid_Error_Sum+1],-4
 01F8 550103            mov [_Ri_Mid_Error_Sum],3
 01FB                   .dbline 383
 01FB           ;       }
 01FB           L21:
 01FB                   .dbline 384
 01FB           ;       if (Ri_Mid_Error_Sum<(-255*16/Ia_PID_Ki))
 01FB 5102              mov A,[_Ri_Mid_Error_Sum+1]
 01FD 1104              sub A,4
 01FF 5101              mov A,[_Ri_Mid_Error_Sum]
 0201 3180              xor A,-128
 0203 197C              sbb A,(-4 ^ 0x80)
 0205 D007              jnc L23
 0207           X22:
 0207                   .dbline 386
 0207           ;       {
 0207           ;               Ri_Mid_Error_Sum=(-255*16/Ia_PID_Ki); // -1020
 0207                   .dbline 386
 0207 550204            mov [_Ri_Mid_Error_Sum+1],4
 020A 5501FC            mov [_Ri_Mid_Error_Sum],-4
 020D                   .dbline 387
 020D           ;       }
 020D           L23:
 020D                   .dbline 388
 020D           ;       Ia_Iout=(Ia_PID_Ki*Ri_Mid_Error_Sum)/16;
 020D 5F0002            mov [__r1],[_Ri_Mid_Error_Sum+1]
 0210 5F0001            mov [__r0],[_Ri_Mid_Error_Sum]
 0213 6500              asl [__r1]
 0215 6B00              rlc [__r0]
 0217 6500              asl [__r1]
 0219 6B00              rlc [__r0]
 021B 5000              mov A,0
 021D 08                push A
 021E 5010              mov A,16
 0220 08                push A
 0221 5100              mov A,[__r0]
 0223 08                push A
 0224 5100              mov A,[__r1]
 0226 08                push A
 0227 7C0000            xcall __divmod_16X16_16
 022A 18                pop A
 022B 530C              mov [_Ia_Iout+1],A
 022D 18                pop A
 022E 530B              mov [_Ia_Iout],A
 0230 38FE              add SP,-2
 0232                   .dbline 389
 0232           ;       Ia_Output=Ia_Output_Bias+Ia_Pout+Ia_Iout;
 0232 510E              mov A,[_Ia_Pout+1]
 0234 0100              add A,0
 0236 5300              mov [__r1],A
 0238 510D              mov A,[_Ia_Pout]
 023A 0901              adc A,1
 023C 5300              mov [__r0],A
 023E 5100              mov A,[__r1]
 0240 020C              add A,[_Ia_Iout+1]
 0242 5310              mov [_Ia_Output+1],A
 0244 5100              mov A,[__r0]
 0246 0A0B              adc A,[_Ia_Iout]
 0248 530F              mov [_Ia_Output],A
 024A                   .dbline 391
 024A           ;       //9 Bit Dac so only 0-511 is allowed, for some reason i put the limit at 510, I foget exactly why.
 024A           ;       if (Ia_Output<0)
 024A 5110              mov A,[_Ia_Output+1]
 024C 1100              sub A,0
 024E 510F              mov A,[_Ia_Output]
 0250 3180              xor A,-128
 0252 1980              sbb A,(0 ^ 0x80)
 0254 D007              jnc L25
 0256           X23:
 0256                   .dbline 393
 0256           ;       {
 0256           ;               Ia_Output=0;
 0256                   .dbline 393
 0256 551000            mov [_Ia_Output+1],0
 0259 550F00            mov [_Ia_Output],0
 025C                   .dbline 394
 025C           ;       }
 025C           L25:
 025C                   .dbline 395
 025C           ;       if (Ia_Output>510)
 025C 50FE              mov A,-2
 025E 1210              sub A,[_Ia_Output+1]
 0260 510F              mov A,[_Ia_Output]
 0262 3180              xor A,-128
 0264 5300              mov [__rX],A
 0266 5081              mov A,(1 ^ 0x80)
 0268 1A00              sbb A,[__rX]
 026A D007              jnc L27
 026C           X24:
 026C                   .dbline 397
 026C           ;       {
 026C           ;               Ia_Output=510;
 026C                   .dbline 397
 026C 5510FE            mov [_Ia_Output+1],-2
 026F 550F01            mov [_Ia_Output],1
 0272                   .dbline 398
 0272           ;       }
 0272           L27:
 0272                   .dbline 399
 0272           ;       DAC9_Ia_WriteStall (Ia_Output);
 0272 10                push X
 0273 580F              mov X,[_Ia_Output]
 0275 5110              mov A,[_Ia_Output+1]
 0277 7C0000            xcall _DAC9_Ia_WriteStall
 027A 20                pop X
 027B                   .dbline -2
 027B           L16:
 027B                   .dbline 0 ; func end
 027B 7F                ret
 027C                   .dbend
 027C                   .dbfunc e IIR_Int _IIR_Int fI
 027C           ;              A -> X-8
 027C           ;           Vout -> X-7
 027C           ;            Vin -> X-5
 027C           _IIR_Int::
 027C                   .dbline -1
 027C 10                push X
 027D 4F                mov X,SP
 027E                   .dbline 403
 027E           ;       //DAC9_Ia_WriteStall (256);
 027E           ; }
 027E           ; INT IIR_Int(INT Vin, INT Vout, BYTE A)
 027E           ; {
 027E                   .dbline 404
 027E           ;       return (Vout + (Vin - Vout)/A);
 027E 52FC              mov A,[X-4]
 0280 13FA              sub A,[X-6]
 0282 5300              mov [__r1],A
 0284 52FB              mov A,[X-5]
 0286 1BF9              sbb A,[X-7]
 0288 5300              mov [__r0],A
 028A 52F8              mov A,[X-8]
 028C 5300              mov [__r3],A
 028E 5000              mov A,0
 0290 08                push A
 0291 5100              mov A,[__r3]
 0293 08                push A
 0294 5100              mov A,[__r0]
 0296 08                push A
 0297 5100              mov A,[__r1]
 0299 08                push A
 029A 7C0000            xcall __divmod_16X16_16
 029D 18                pop A
 029E 5300              mov [__r1],A
 02A0 18                pop A
 02A1 5300              mov [__r0],A
 02A3 38FE              add SP,-2
 02A5 52FA              mov A,[X-6]
 02A7 0200              add A,[__r1]
 02A9 5300              mov [__r1],A
 02AB 52F9              mov A,[X-7]
 02AD 0A00              adc A,[__r0]
 02AF 5300              mov [__r0],A
 02B1                   .dbline -2
 02B1           L29:
 02B1 20                pop X
 02B2                   .dbline 0 ; func end
 02B2 7F                ret
 02B3                   .dbsym l A -8 c
 02B3                   .dbsym l Vout -7 I
 02B3                   .dbsym l Vin -5 I
 02B3                   .dbend
                        .area data(ram, con, rel)
 0006                   .dbfile I:\PSOCDO~1\WBOOS_~2\DSTAGE~1\DSTAGE~1\main.c
 0006           _Ia_PID_Counter::
 0006                   .blkb 1
                        .area idata(rom,lit)
 0006 00                .byte 0
                        .area data(ram, con, rel)
 0007                   .dbfile I:\PSOCDO~1\WBOOS_~2\DSTAGE~1\DSTAGE~1\main.c
 0007                   .dbsym e Ia_PID_Counter _Ia_PID_Counter c
 0007           _Vout_Lookup_Counter::
 0007                   .blkb 1
                        .area idata(rom,lit)
 0007 00                .byte 0
                        .area data(ram, con, rel)
 0008                   .dbfile I:\PSOCDO~1\WBOOS_~2\DSTAGE~1\DSTAGE~1\main.c
 0008                   .dbsym e Vout_Lookup_Counter _Vout_Lookup_Counter c
 0008           _Heater_PID_Counter::
 0008                   .blkb 1
                        .area idata(rom,lit)
 0008 00                .byte 0
                        .area data(ram, con, rel)
 0009                   .dbfile I:\PSOCDO~1\WBOOS_~2\DSTAGE~1\DSTAGE~1\main.c
 0009                   .dbsym e Heater_PID_Counter _Heater_PID_Counter c
 0009           _LCD_Counter::
 0009                   .blkb 1
                        .area idata(rom,lit)
 0009 00                .byte 0
                        .area data(ram, con, rel)
 000A                   .dbfile I:\PSOCDO~1\WBOOS_~2\DSTAGE~1\DSTAGE~1\main.c
 000A                   .dbsym e LCD_Counter _LCD_Counter c
 000A           _Heatup_Counter::
 000A                   .blkb 1
                        .area idata(rom,lit)
 000A 00                .byte 0
                        .area data(ram, con, rel)
 000B                   .dbfile I:\PSOCDO~1\WBOOS_~2\DSTAGE~1\DSTAGE~1\main.c
 000B                   .dbsym e Heatup_Counter _Heatup_Counter c
                        .area lit(rom, con, rel, lit)
 014A           L31:
 014A 0006              .byte 0,6
 014C 4040              .byte 64,64
                        .area text(rom, con, rel)
 02B3                   .dbfile I:\PSOCDO~1\WBOOS_~2\DSTAGE~1\DSTAGE~1\main.c
 02B3                   .dbfunc e main _main fV
 02B3           ;     temp_byte2 -> X+14
 02B3           ;      temp_int2 -> X+12
 02B3           ;     heater_dot -> X+11
 02B3           ;     temp_ulong -> X+7
 02B3           ;         digits -> X+3
 02B3           ;      temp_byte -> X+2
 02B3           ;       temp_int -> X+0
 02B3           _main::
 02B3                   .dbline -1
 02B3 10                push X
 02B4 4F                mov X,SP
 02B5 380F              add SP,15
 02B7                   .dbline 420
 02B7           ; }
 02B7           ; 
 02B7           ; 
 02B7           ; BYTE Ia_PID_Counter=0;
 02B7           ; BYTE Vout_Lookup_Counter=0;
 02B7           ; BYTE Heater_PID_Counter=0;
 02B7           ; BYTE LCD_Counter=0;
 02B7           ; BYTE Heatup_Counter=0;
 02B7           ; INT Ri_Min,Ri_Max;
 02B7           ; INT ip,ip_Justified;
 02B7           ; BYTE Lambda_x100;
 02B7           ; INT LSU_Temperature_C;
 02B7           ; //char Str1[] = "Lambda=x.xx";
 02B7           ; //char Str2[] = "Temperature=xxxC"; 
 02B7           ; void main(void)
 02B7           ; {
 02B7                   .dbline 427
 02B7           ;       unsigned long temp_ulong;
 02B7           ;       INT temp_int,temp_int2;
 02B7           ;       BYTE temp_byte, temp_byte2;
 02B7           ;       
 02B7           ;       #if defined LED_AFR || defined LED_Lambda
 02B7           ;               // empty, 1, -, -
 02B7           ;               BYTE digits[4] = {0b00000000, 0b00000110, 0b01000000, 0b01000000};
 02B7 55004A            mov [__r1],<L31
 02BA 55004A            mov [__r0],>L31
 02BD 5A00              mov [__r3],X
 02BF 060003            add [__r3],3
 02C2 10                push X
 02C3 550000            mov [__rX],0
 02C6 5100              mov A,[__r0]
 02C8 5800              mov X,[__r1]
 02CA           X26:
 02CA 08                push A
 02CB 28                romx
 02CC 3F00              mvi [__r3],A
 02CE 18                pop A
 02CF 75                inc X
 02D0 0900              adc A,0
 02D2 7600              inc [__rX]
 02D4 3C0004            cmp [__rX],4
 02D7 BFF2              jnz X26
 02D9 20                pop X
 02DA                   .dbline 428
 02DA           ;               BYTE heater_dot = 0x00;
 02DA 560B00            mov [X+11],0
 02DD                   .dbline 431
 02DD           ;       #endif
 02DD           ;       
 02DD           ;       AMUX4_0_InputSelect(AMUX4_0_PORT0_1);        
 02DD 10                push X
 02DE 5000              mov A,0
 02E0 7C0000            xcall _AMUX4_0_InputSelect
 02E3                   .dbline 432
 02E3           ;       AMUX4_1_InputSelect(AMUX4_1_PORT0_0);
 02E3 5000              mov A,0
 02E5 7C0000            xcall _AMUX4_1_InputSelect
 02E8                   .dbline 433
 02E8           ;       INSAMP_Start(INSAMP_LOWPOWER); 
 02E8 5001              mov A,1
 02EA 7C0000            xcall _INSAMP_Start
 02ED                   .dbline 434
 02ED           ;     ADCINC_Start(ADCINC_HIGHPOWER);      
 02ED 5003              mov A,3
 02EF 7C0000            xcall _ADCINC_Start
 02F2                   .dbline 435
 02F2           ;       DAC9_Ia_Start(DAC9_Ia_HIGHPOWER);
 02F2 5003              mov A,3
 02F4 7C0000            xcall _DAC9_Ia_Start
 02F7                   .dbline 436
 02F7           ;       DAC6_VGND_Start(DAC6_VGND_MEDPOWER);
 02F7 5002              mov A,2
 02F9 7C0000            xcall _DAC6_VGND_Start
 02FC                   .dbline 437
 02FC           ;       DAC6_VGND_WriteStall (31);
 02FC 501F              mov A,31
 02FE 7C0000            xcall _DAC6_VGND_WriteStall
 0301                   .dbline 438
 0301           ;     PWM8_Vout_DisableInt();  
 0301 7C0000            xcall _PWM8_Vout_DisableInt
 0304                   .dbline 439
 0304           ;     PWM8_Vout_Start();     
 0304 7C0000            xcall _PWM8_Vout_Start
 0307                   .dbline 440
 0307           ;     PWM8_Heater_DisableInt();  
 0307 7C0000            xcall _PWM8_Heater_DisableInt
 030A                   .dbline 441
 030A           ;     PWM8_Heater_Start();
 030A 7C0000            xcall _PWM8_Heater_Start
 030D                   .dbline 442
 030D           ;       PWM8_NB_Out_DisableInt();  
 030D 7C0000            xcall _PWM8_NB_Out_DisableInt
 0310                   .dbline 443
 0310           ;     PWM8_NB_Out_Start(); 
 0310 7C0000            xcall _PWM8_NB_Out_Start
 0313                   .dbline 444
 0313           ;       ADCINC_GetSamples(0);
 0313 5000              mov A,0
 0315 7C0000            xcall _ADCINC_GetSamples
 0318                   .dbline 445
 0318           ;       SleepTimer_Start();  
 0318 7C0000            xcall _SleepTimer_Start
 031B                   .dbline 446
 031B           ;       SleepTimer_SetInterval(SleepTimer_512_HZ);  
 031B 5000              mov A,0
 031D 7C0000            xcall _SleepTimer_SetInterval
 0320                   .dbline 447
 0320           ;       SleepTimer_EnableInt();   
 0320 7C0000            xcall _SleepTimer_EnableInt
 0323 20                pop X
 0324                   .dbline 448
 0324           ;       M8C_EnableGInt ;  
 0324 7101                      or  F, 01h
 0326           
 0326                   .dbline 495
 0326           ;       
 0326           ;       // initialize LCD only when needed (DStage WBOOS can be used with LED or without any display)
 0326           ;       #if defined LCD_AFR_digits || defined LCD_Lambda_digits || defined LCD_Temperature_digits || defined DStage_logo || defined LCD_Lambda_Graph || defined LCD_Temperature_Graph
 0326           ;               LCD_Start();                  // Initialize LCD
 0326           ;               LCD_InitBG(LCD_SOLID_BG);
 0326           ;       #endif
 0326           ; 
 0326           ;       #ifdef LCD_AFR_digits
 0326           ;               LCD_Position(0,0);
 0326           ;               LCD_PrCString("AFR: 1\0");
 0326           ;       #endif
 0326           ;       
 0326           ;       #ifdef LCD_Lambda_digits
 0326           ;               #ifndef LCD_AFR_digits
 0326           ;                       LCD_Position(0,0);
 0326           ;                       LCD_PrCString("LAM: 0\0");
 0326           ;               #else
 0326           ;                       LCD_Position(1,0);
 0326           ;                       LCD_PrCString("LAM: 0\0");
 0326           ;               #endif
 0326           ;       #endif
 0326           ;       
 0326           ;       #ifdef LCD_Temperature_digits
 0326           ;               #if defined LCD_Lambda_Graph || (defined LCD_AFR_digits && defined LCD_Lambda_digits)
 0326           ;                       LCD_Position(0,10);
 0326           ;                       LCD_PrCString("T:\0");
 0326           ;                       LCD_Position(0,15);
 0326           ;                       LCD_WriteData(0xDF); // degre
 0326           ;               #else
 0326           ;                       LCD_Position(1,0);
 0326           ;                       LCD_PrCString("TMP:\0");
 0326           ;                       LCD_Position(1,8);
 0326           ;                       LCD_WriteData(0xDF); // degre
 0326           ;               #endif
 0326           ;       #endif
 0326           ;       
 0326           ;       #ifdef DStage_logo
 0326           ;               #ifndef LCD_Lambda_Graph
 0326           ;                       LCD_Position(0,10);
 0326           ;                       LCD_PrCString("DStage\0");
 0326           ;                       LCD_Position(1,10);
 0326           ;                       LCD_PrCString("Garage\0");
 0326           ;               #endif
 0326           ;       #endif
 0326           ;       
 0326           ;       #if defined LED_AFR || defined LED_Lambda
 0326           ;               TM1637_init();
 0326 92E3              xcall _TM1637_init
 0328                   .dbline 496
 0328           ;               TM1637_setSegments(digits, 4, 0);
 0328 5000              mov A,0
 032A 08                push A
 032B 5004              mov A,4
 032D 08                push A
 032E 5A00              mov [__r1],X
 0330 060003            add [__r1],3
 0333 5100              mov A,[__r0]
 0335 08                push A
 0336 5100              mov A,[__r1]
 0338 08                push A
 0339 92FE              xcall _TM1637_setSegments
 033B 38FC              add SP,-4
 033D                   .dbline 500
 033D           ;               //TM1637_showNumberDec(123, 0, 3, 1);
 033D           ;       #endif
 033D           ; 
 033D           ;       for(;;)
 033D           L32:
 033D                   .dbline 501
 033D           ;     {
 033D                   .dbline 502
 033D           ;               temp_ulong++;
 033D 070A01            add [X+10],1
 0340 0F0900            adc [X+9],0
 0343 0F0800            adc [X+8],0
 0346 0F0700            adc [X+7],0
 0349                   .dbline 503
 0349           ;               if ((ADC_IF&1)==1)
 0349 5100              mov A,[_ADC_IF]
 034B 2101              and A,1
 034D 3901              cmp A,1
 034F B056              jnz L36
 0351                   .dbline 505
 0351           ;               {
 0351           ;                       ADC_IF=ADC_IF&254;
 0351                   .dbline 505
 0351 2600FE            and [_ADC_IF],-2
 0354                   .dbline 506
 0354           ;                       Ri_Min=IIR_Int(Ri_Min_x1*2,Ri_Min,Ri_Filter_Strength);
 0354 5004              mov A,4
 0356 08                push A
 0357 5109              mov A,[_Ri_Min]
 0359 08                push A
 035A 510A              mov A,[_Ri_Min+1]
 035C 08                push A
 035D 5F0000            mov [__r1],[_Ri_Min_x1]
 0360 550000            mov [__r0],0
 0363 6500              asl [__r1]
 0365 6B00              rlc [__r0]
 0367 5100              mov A,[__r0]
 0369 08                push A
 036A 5100              mov A,[__r1]
 036C 08                push A
 036D 9F0D              xcall _IIR_Int
 036F 38FB              add SP,-5
 0371 5F0A00            mov [_Ri_Min+1],[__r1]
 0374 5F0900            mov [_Ri_Min],[__r0]
 0377                   .dbline 507
 0377           ;                       Ri_Delta=Ri_Max-Ri_Min;
 0377 5108              mov A,[_Ri_Max+1]
 0379 120A              sub A,[_Ri_Min+1]
 037B 531C              mov [_Ri_Delta+1],A
 037D 5107              mov A,[_Ri_Max]
 037F 1A09              sbb A,[_Ri_Min]
 0381 531B              mov [_Ri_Delta],A
 0383                   .dbline 508
 0383           ;                       Ri_Mid=(Ri_Max+Ri_Min)/2;
 0383 5108              mov A,[_Ri_Max+1]
 0385 020A              add A,[_Ri_Min+1]
 0387 5300              mov [__r1],A
 0389 5107              mov A,[_Ri_Max]
 038B 0A09              adc A,[_Ri_Min]
 038D 5300              mov [__r0],A
 038F 5000              mov A,0
 0391 08                push A
 0392 5002              mov A,2
 0394 08                push A
 0395 5100              mov A,[__r0]
 0397 08                push A
 0398 5100              mov A,[__r1]
 039A 08                push A
 039B 7C0000            xcall __divmod_16X16_16
 039E 18                pop A
 039F 531E              mov [_Ri_Mid+1],A
 03A1 18                pop A
 03A2 531D              mov [_Ri_Mid],A
 03A4 38FE              add SP,-2
 03A6                   .dbline 509
 03A6           ;               }
 03A6           L36:
 03A6                   .dbline 510
 03A6           ;               if ((ADC_IF&2)==2)
 03A6 5100              mov A,[_ADC_IF]
 03A8 2102              and A,2
 03AA 3902              cmp A,2
 03AC B056              jnz L38
 03AE                   .dbline 512
 03AE           ;               {
 03AE           ;                       ADC_IF=ADC_IF&253;
 03AE                   .dbline 512
 03AE 2600FD            and [_ADC_IF],-3
 03B1                   .dbline 513
 03B1           ;                       Ri_Max=IIR_Int(Ri_Max_x1*2,Ri_Max,Ri_Filter_Strength);
 03B1 5004              mov A,4
 03B3 08                push A
 03B4 5107              mov A,[_Ri_Max]
 03B6 08                push A
 03B7 5108              mov A,[_Ri_Max+1]
 03B9 08                push A
 03BA 5F0000            mov [__r1],[_Ri_Max_x1]
 03BD 550000            mov [__r0],0
 03C0 6500              asl [__r1]
 03C2 6B00              rlc [__r0]
 03C4 5100              mov A,[__r0]
 03C6 08                push A
 03C7 5100              mov A,[__r1]
 03C9 08                push A
 03CA 9EB0              xcall _IIR_Int
 03CC 38FB              add SP,-5
 03CE 5F0800            mov [_Ri_Max+1],[__r1]
 03D1 5F0700            mov [_Ri_Max],[__r0]
 03D4                   .dbline 514
 03D4           ;                       Ri_Delta=Ri_Max-Ri_Min;
 03D4 5108              mov A,[_Ri_Max+1]
 03D6 120A              sub A,[_Ri_Min+1]
 03D8 531C              mov [_Ri_Delta+1],A
 03DA 5107              mov A,[_Ri_Max]
 03DC 1A09              sbb A,[_Ri_Min]
 03DE 531B              mov [_Ri_Delta],A
 03E0                   .dbline 515
 03E0           ;                       Ri_Mid=(Ri_Max+Ri_Min)/2;
 03E0 5108              mov A,[_Ri_Max+1]
 03E2 020A              add A,[_Ri_Min+1]
 03E4 5300              mov [__r1],A
 03E6 5107              mov A,[_Ri_Max]
 03E8 0A09              adc A,[_Ri_Min]
 03EA 5300              mov [__r0],A
 03EC 5000              mov A,0
 03EE 08                push A
 03EF 5002              mov A,2
 03F1 08                push A
 03F2 5100              mov A,[__r0]
 03F4 08                push A
 03F5 5100              mov A,[__r1]
 03F7 08                push A
 03F8 7C0000            xcall __divmod_16X16_16
 03FB 18                pop A
 03FC 531E              mov [_Ri_Mid+1],A
 03FE 18                pop A
 03FF 531D              mov [_Ri_Mid],A
 0401 38FE              add SP,-2
 0403                   .dbline 516
 0403           ;               }
 0403           L38:
 0403                   .dbline 517
 0403           ;               if ((ADC_IF&4)==4)
 0403 5100              mov A,[_ADC_IF]
 0405 2104              and A,4
 0407 3904              cmp A,4
 0409 B027              jnz L40
 040B                   .dbline 519
 040B           ;               {
 040B           ;                       ADC_IF=ADC_IF&251;
 040B                   .dbline 519
 040B 2600FB            and [_ADC_IF],-5
 040E                   .dbline 520
 040E           ;                       ip=IIR_Int(ip_x1*2,ip,ip_Filter_Strength);
 040E 5004              mov A,4
 0410 08                push A
 0411 5105              mov A,[_ip]
 0413 08                push A
 0414 5106              mov A,[_ip+1]
 0416 08                push A
 0417 5F0000            mov [__r1],[_ip_x1]
 041A 550000            mov [__r0],0
 041D 6500              asl [__r1]
 041F 6B00              rlc [__r0]
 0421 5100              mov A,[__r0]
 0423 08                push A
 0424 5100              mov A,[__r1]
 0426 08                push A
 0427 9E53              xcall _IIR_Int
 0429 38FB              add SP,-5
 042B 5F0600            mov [_ip+1],[__r1]
 042E 5F0500            mov [_ip],[__r0]
 0431                   .dbline 521
 0431           ;               }
 0431           L40:
 0431                   .dbline 522
 0431           ;               Ia_PID_Counter+=Sleep_Counter;
 0431 5100              mov A,[_Sleep_Counter]
 0433 0406              add [_Ia_PID_Counter],A
 0435                   .dbline 523
 0435           ;               Heater_PID_Counter+=Sleep_Counter;
 0435 5100              mov A,[_Sleep_Counter]
 0437 0408              add [_Heater_PID_Counter],A
 0439                   .dbline 524
 0439           ;               Heatup_Counter+=Sleep_Counter;
 0439 5100              mov A,[_Sleep_Counter]
 043B 040A              add [_Heatup_Counter],A
 043D                   .dbline 525
 043D           ;               Vout_Lookup_Counter+=Sleep_Counter;
 043D 5100              mov A,[_Sleep_Counter]
 043F 0407              add [_Vout_Lookup_Counter],A
 0441                   .dbline 526
 0441           ;               LCD_Counter+=Sleep_Counter;
 0441 5100              mov A,[_Sleep_Counter]
 0443 0409              add [_LCD_Counter],A
 0445                   .dbline 527
 0445           ;               Sleep_Counter=0;
 0445 550000            mov [_Sleep_Counter],0
 0448                   .dbline 528
 0448           ;               if (Ia_PID_Counter>Ia_PID_Counter_Set)
 0448 5001              mov A,1
 044A 3A06              cmp A,[_Ia_PID_Counter]
 044C D006              jnc L42
 044E           X27:
 044E                   .dbline 530
 044E           ;               {
 044E           ;                       Ia_PID_Counter=0;
 044E                   .dbline 530
 044E 550600            mov [_Ia_PID_Counter],0
 0451                   .dbline 531
 0451           ;                       Ia_PID();
 0451 9D07              xcall _Ia_PID
 0453                   .dbline 532
 0453           ;               }
 0453           L42:
 0453                   .dbline 533
 0453           ;               if (Heater_PID_Counter>Heater_PID_Counter_Set)
 0453 5019              mov A,25
 0455 3A08              cmp A,[_Heater_PID_Counter]
 0457 D006              jnc L44
 0459           X28:
 0459                   .dbline 535
 0459           ;               {
 0459           ;                       Heater_PID_Counter=0;
 0459                   .dbline 535
 0459 550800            mov [_Heater_PID_Counter],0
 045C                   .dbline 536
 045C           ;                       Heater_PID();
 045C 9BA2              xcall _Heater_PID
 045E                   .dbline 537
 045E           ;               }
 045E           L44:
 045E                   .dbline 538
 045E           ;               if (Vout_Lookup_Counter>Vout_Lookup_Counter_Set)
 045E 5019              mov A,25
 0460 3A07              cmp A,[_Vout_Lookup_Counter]
 0462 D076              jnc L46
 0464           X29:
 0464                   .dbline 540
 0464           ;               {
 0464           ;                       Vout_Lookup_Counter=0;
 0464                   .dbline 540
 0464 550700            mov [_Vout_Lookup_Counter],0
 0467                   .dbline 541
 0467           ;                       temp_int=ip-ip_to_Vout_Lookup_Start;
 0467 5106              mov A,[_ip+1]
 0469 1187              sub A,-121
 046B 5401              mov [X+1],A
 046D 5105              mov A,[_ip]
 046F 1900              sbb A,0
 0471 5400              mov [X+0],A
 0473                   .dbline 542
 0473           ;                       if (temp_int<0)
 0473 5201              mov A,[X+1]
 0475 1100              sub A,0
 0477 5200              mov A,[X+0]
 0479 3180              xor A,-128
 047B 1980              sbb A,(0 ^ 0x80)
 047D D007              jnc L48
 047F           X30:
 047F                   .dbline 544
 047F           ;                       {
 047F           ;                               temp_int=0;
 047F                   .dbline 544
 047F 560100            mov [X+1],0
 0482 560000            mov [X+0],0
 0485                   .dbline 545
 0485           ;                       }
 0485           L48:
 0485                   .dbline 546
 0485           ;                       if (temp_int>(ip_to_Vout_Lookup_Size-1))
 0485 509D              mov A,-99
 0487 1301              sub A,[X+1]
 0489 5200              mov A,[X+0]
 048B 3180              xor A,-128
 048D 5300              mov [__rX],A
 048F 5080              mov A,(0 ^ 0x80)
 0491 1A00              sbb A,[__rX]
 0493 D007              jnc L50
 0495           X31:
 0495                   .dbline 548
 0495           ;                       {
 0495           ;                               temp_int=(ip_to_Vout_Lookup_Size-1);
 0495                   .dbline 548
 0495 56019D            mov [X+1],-99
 0498 560000            mov [X+0],0
 049B                   .dbline 549
 049B           ;                       }
 049B           L50:
 049B                   .dbline 550
 049B           ;                       PWM8_Vout_WritePulseWidth(ip_to_Vout_Lookup[temp_int]);
 049B 5201              mov A,[X+1]
 049D 0100              add A,<_ip_to_Vout_Lookup
 049F 5300              mov [__r1],A
 04A1 5200              mov A,[X+0]
 04A3 0900              adc A,>_ip_to_Vout_Lookup
 04A5 10                push X
 04A6 5800              mov X,[__r1]
 04A8 28                romx
 04A9 7C0000            xcall _PWM8_Vout_WritePulseWidth
 04AC 20                pop X
 04AD                   .dbline 553
 04AD           ;                       
 04AD           ;                       #ifdef NB_Out
 04AD           ;                               temp_byte=23;//0.45v
 04AD 560217            mov [X+2],23
 04B0                   .dbline 554
 04B0           ;                               if (ip<251) // 251 =0.9797787392968
 04B0 5106              mov A,[_ip+1]
 04B2 11FB              sub A,-5
 04B4 5105              mov A,[_ip]
 04B6 3180              xor A,-128
 04B8 1980              sbb A,(0 ^ 0x80)
 04BA D004              jnc L52
 04BC           X32:
 04BC                   .dbline 556
 04BC           ;                               {
 04BC           ;                                       temp_byte=46; //0.9v
 04BC                   .dbline 556
 04BC 56022E            mov [X+2],46
 04BF                   .dbline 558
 04BF           ;                                       
 04BF           ;                               }
 04BF           L52:
 04BF                   .dbline 559
 04BF           ;                               if (ip>259) //259 = 1.02295956968912
 04BF 5003              mov A,3
 04C1 1206              sub A,[_ip+1]
 04C3 5105              mov A,[_ip]
 04C5 3180              xor A,-128
 04C7 5300              mov [__rX],A
 04C9 5081              mov A,(1 ^ 0x80)
 04CB 1A00              sbb A,[__rX]
 04CD D004              jnc L54
 04CF           X33:
 04CF                   .dbline 561
 04CF           ;                               {
 04CF           ;                                       temp_byte=0; //0v
 04CF                   .dbline 561
 04CF 560200            mov [X+2],0
 04D2                   .dbline 562
 04D2           ;                               }
 04D2           L54:
 04D2                   .dbline 563
 04D2           ;                               PWM8_NB_Out_WritePulseWidth(temp_byte);
 04D2 10                push X
 04D3 5202              mov A,[X+2]
 04D5 7C0000            xcall _PWM8_NB_Out_WritePulseWidth
 04D8 20                pop X
 04D9                   .dbline 572
 04D9           ;                       #endif
 04D9           ;                       
 04D9           ;                       #ifdef NB_simple_Out
 04D9           ;                               temp_byte=0; //0v                               
 04D9           ;                               if (ip<260) // 251 =0.9797787392968
 04D9           ;                                       temp_byte=46; //0.9v
 04D9           ;                               PWM8_NB_Out_WritePulseWidth(temp_byte);
 04D9           ;                       #endif                  
 04D9           ;               }
 04D9           L46:
 04D9                   .dbline 573
 04D9           ;               if (LCD_Counter>LCD_Counter_Set)
 04D9 5032              mov A,50
 04DB 3A09              cmp A,[_LCD_Counter]
 04DD D0E5              jnc L56
 04DF           X34:
 04DF                   .dbline 575
 04DF           ;               {
 04DF           ;                       LCD_Counter=0;
 04DF                   .dbline 575
 04DF 550900            mov [_LCD_Counter],0
 04E2                   .dbline 702
 04E2           ;                       
 04E2           ;                       #ifdef LCD_Lambda_Graph
 04E2           ;                               temp_int=ip-ip_to_Lambda_Lookup_Start;
 04E2           ;                               if (temp_int<0)
 04E2           ;                               {
 04E2           ;                                       temp_int=0;
 04E2           ;                               }
 04E2           ;                               if (temp_int>(ip_to_Lambda_Lookup_Size-1))
 04E2           ;                               {
 04E2           ;                                       temp_int=(ip_to_Lambda_Lookup_Size-1);
 04E2           ;                               }
 04E2           ;                               Lambda_x100=ip_to_Graph_Lookup[temp_int];
 04E2           ;                               
 04E2           ;                               // if both numeric AFR and Lambda bargraph is to be used put bargraph in second row
 04E2           ;                               #ifdef LCD_AFR_digits
 04E2           ;                                       LCD_DrawBG(1,0,16,Lambda_x100);
 04E2           ;                               #else
 04E2           ;                                       #ifdef LCD_Lambda_digits
 04E2           ;                                               LCD_DrawBG(1,0,16,Lambda_x100);
 04E2           ;                                       #else
 04E2           ;                                               LCD_DrawBG(0,0,16,Lambda_x100);
 04E2           ;                                       #endif
 04E2           ;                               #endif
 04E2           ;                       #endif
 04E2           ;                       
 04E2           ;                       #ifdef LCD_AFR_digits
 04E2           ;                               temp_int=ip-ip_to_AFR_Lookup_Start;
 04E2           ;                               if (temp_int<0)
 04E2           ;                               {
 04E2           ;                                       temp_int=0;
 04E2           ;                               }
 04E2           ;                               if (temp_int>(ip_to_AFR_Lookup_Size-1))
 04E2           ;                               {
 04E2           ;                                       temp_int=(ip_to_AFR_Lookup_Size-1);
 04E2           ;                               }
 04E2           ;                               temp_byte = temp_int;   // code size optimization
 04E2           ;                               
 04E2           ;                               // AFR integer part (temporarly first digit is always "1")
 04E2           ;                               LCD_Position(0,6);
 04E2           ;                               LCD_WriteData('0' + ((ip_to_AFR_Lookup[temp_byte] & 0xF0) >> 4));
 04E2           ;                               
 04E2           ;                               // AFR decimal point part
 04E2           ;                               LCD_WriteData('.');
 04E2           ;                               LCD_WriteData('0' + (ip_to_AFR_Lookup[temp_byte] & 0x0F));
 04E2           ;                       #endif
 04E2           ;                       
 04E2           ;                       #ifdef LCD_Lambda_digits
 04E2           ;                               temp_int=ip-ip_to_LambdaD_Lookup_Start; 
 04E2           ;                               if (temp_int<0)
 04E2           ;                               {
 04E2           ;                                       temp_int=0;
 04E2           ;                               }
 04E2           ;                               if (temp_int>(ip_to_LambdaD_Lookup_Size-1))
 04E2           ;                               {
 04E2           ;                                       temp_int=(ip_to_LambdaD_Lookup_Size-1);
 04E2           ;                               }
 04E2           ;                               temp_byte = temp_int;   // code size optimization
 04E2           ;                               
 04E2           ;                               // Lambda int part      
 04E2           ;                               #ifndef LCD_AFR_digits
 04E2           ;                                       LCD_Position(0,5);
 04E2           ;                               #else
 04E2           ;                                       LCD_Position(1,5);
 04E2           ;                               #endif
 04E2           ;                               if (temp_byte < 120)    // 120th value is equal to lambda 1.00
 04E2           ;                                       Lambda_x100 = '0';
 04E2           ;                               else
 04E2           ;                                       Lambda_x100 = '1';
 04E2           ;                               LCD_WriteData(Lambda_x100);
 04E2           ;                               
 04E2           ;                               // Lambda 0.x part
 04E2           ;                               LCD_WriteData('.');
 04E2           ;                               LCD_WriteData('0' + ((ip_to_Lambda_Lookup[temp_byte] & 0xF0) >> 4));
 04E2           ;                               
 04E2           ;                               // Lambda 0.0x part
 04E2           ;                               LCD_WriteData('0' + (ip_to_Lambda_Lookup[temp_byte] & 0x0F));
 04E2           ;                       #endif
 04E2           ;                       
 04E2           ;                       #ifdef LCD_Temperature_Graph
 04E2           ;                               temp_int=Ri_Delta-Ri_Delta_to_Temperature_C_Start;
 04E2           ;                               if (temp_int<0)
 04E2           ;                               {
 04E2           ;                                       temp_int=0;
 04E2           ;                               }
 04E2           ;                               if (temp_int>(Ri_Delta_to_Temperature_C_Size-1))
 04E2           ;                               {
 04E2           ;                                       temp_int=(Ri_Delta_to_Temperature_C_Size-1);
 04E2           ;                               }
 04E2           ;                               LSU_Temperature_C=Ri_Delta_to_Graph[temp_int];
 04E2           ;                               LCD_DrawBG(1,0,16,LSU_Temperature_C);
 04E2           ;                       #endif
 04E2           ;                       
 04E2           ;                       #ifdef LCD_Temperature_digits
 04E2           ;                               temp_int=Ri_Delta-Ri_Delta_to_Temperature_C_dig_Start;
 04E2           ;                               if (temp_int<0)
 04E2           ;                               {
 04E2           ;                                       temp_int=0;
 04E2           ;                               }
 04E2           ;                               if (temp_int>(Ri_Delta_to_Temperature_C_dig_Size-1))
 04E2           ;                               {
 04E2           ;                                       temp_int=(Ri_Delta_to_Temperature_C_dig_Size-1);
 04E2           ;                               }
 04E2           ;                               temp_byte = temp_int;   // code size optimization
 04E2           ;       
 04E2           ;                               // Temperature hundreds part (7 or 8)   
 04E2           ;                               #if defined LCD_Lambda_Graph || (defined LCD_AFR_digits && defined LCD_Lambda_digits)
 04E2           ;                                       LCD_Position(0,12);
 04E2           ;                               #else
 04E2           ;                                       LCD_Position(1,5);
 04E2           ;                               #endif
 04E2           ; 
 04E2           ;                               if (temp_byte < 15)
 04E2           ;                                       Lambda_x100 = '8';
 04E2           ;                               else
 04E2           ;                                       Lambda_x100 = '7';
 04E2           ;                               
 04E2           ;                               LCD_WriteData(Lambda_x100);
 04E2           ;                                               
 04E2           ;                               // Temperature tens part
 04E2           ;                               LCD_WriteData('0' + ((Ri_Delta_to_dig[temp_int] & 0xF0) >> 4));
 04E2           ;                               
 04E2           ;                               // Temperature ones part
 04E2           ;                               LCD_WriteData('0' + (Ri_Delta_to_dig[temp_int] & 0x0F));
 04E2           ;                       #endif
 04E2           ;                       
 04E2           ;                       #ifdef LED_AFR          
 04E2           ;                               temp_int=ip-ip_to_AFR_Lookup_Start;
 04E2 5106              mov A,[_ip+1]
 04E4 1187              sub A,-121
 04E6 5401              mov [X+1],A
 04E8 5105              mov A,[_ip]
 04EA 1900              sbb A,0
 04EC 5400              mov [X+0],A
 04EE                   .dbline 703
 04EE           ;                               if (temp_int<0)
 04EE 5201              mov A,[X+1]
 04F0 1100              sub A,0
 04F2 5200              mov A,[X+0]
 04F4 3180              xor A,-128
 04F6 1980              sbb A,(0 ^ 0x80)
 04F8 D007              jnc L58
 04FA           X35:
 04FA                   .dbline 705
 04FA           ;                               {
 04FA           ;                                       temp_int=0;
 04FA                   .dbline 705
 04FA 560100            mov [X+1],0
 04FD 560000            mov [X+0],0
 0500                   .dbline 706
 0500           ;                               }
 0500           L58:
 0500                   .dbline 707
 0500           ;                               if (temp_int>(ip_to_AFR_Lookup_Size-1))
 0500 509D              mov A,-99
 0502 1301              sub A,[X+1]
 0504 5200              mov A,[X+0]
 0506 3180              xor A,-128
 0508 5300              mov [__rX],A
 050A 5080              mov A,(0 ^ 0x80)
 050C 1A00              sbb A,[__rX]
 050E D007              jnc L60
 0510           X36:
 0510                   .dbline 709
 0510           ;                               {
 0510           ;                                       temp_int=(ip_to_AFR_Lookup_Size-1);
 0510                   .dbline 709
 0510 56019D            mov [X+1],-99
 0513 560000            mov [X+0],0
 0516                   .dbline 710
 0516           ;                               }
 0516           L60:
 0516                   .dbline 711
 0516           ;                               temp_byte = temp_int;   // code size optimization
 0516 5201              mov A,[X+1]
 0518 5402              mov [X+2],A
 051A                   .dbline 727
 051A           ;                                                       
 051A           ;                               #ifdef LED_Lambda
 051A           ;                                       if ((SWPORT & SWPIN) == 0)
 051A           ;                                       {
 051A           ;                                               // AFR integer part (temporarly first digit is always "1"), add dot
 051A           ;                                               digits[1] = digitToSegment[(ip_to_AFR_Lookup[temp_byte] & 0xF0) >> 4] | 0x80;
 051A           ;                                               
 051A           ;                                               // AFR decimal part, far right decimal point blinking indicates sensor heating
 051A           ;                                               digits[2] = digitToSegment[ip_to_AFR_Lookup[temp_byte] & 0x0F] | heater_dot;
 051A           ;                                               
 051A           ;                                               digits[0] = digitToSegment[1]; // as simplification the first digit is always "1"
 051A           ;                                               TM1637_setSegments(digits, 3, 1);
 051A           ;                                       }       
 051A           ;                               #else
 051A           ;                                       // AFR integer part (temporarly first digit is always "1"), add dot
 051A           ;                                       digits[0] = digitToSegment[(ip_to_AFR_Lookup[temp_byte] & 0xF0) >> 4] | 0x80;
 051A 5202              mov A,[X+2]
 051C 5300              mov [__r1],A
 051E 550000            mov [__r0],0
 0521 06009E            add [__r1],<_ip_to_AFR_Lookup
 0524 0E009E            adc [__r0],>_ip_to_AFR_Lookup
 0527 5100              mov A,[__r0]
 0529 10                push X
 052A 5800              mov X,[__r1]
 052C 28                romx
 052D 20                pop X
 052E 5300              mov [__r1],A
 0530 550000            mov [__r0],0
 0533 2600F0            and [__r1],-16
 0536 260000            and [__r0],0
 0539 6800              asr [__r0]
 053B 6E00              rrc [__r1]
 053D 6800              asr [__r0]
 053F 6E00              rrc [__r1]
 0541 6800              asr [__r0]
 0543 6E00              rrc [__r1]
 0545 6800              asr [__r0]
 0547 6E00              rrc [__r1]
 0549 06003C            add [__r1],<_digitToSegment
 054C 0E003C            adc [__r0],>_digitToSegment
 054F 5100              mov A,[__r0]
 0551 10                push X
 0552 5800              mov X,[__r1]
 0554 28                romx
 0555 20                pop X
 0556 2980              or A,-128
 0558 5403              mov [X+3],A
 055A                   .dbline 730
 055A           ;                               
 055A           ;                                       // AFR decimal part, far right decimal point blinking indicates sensor heating
 055A           ;                                       digits[1] = digitToSegment[ip_to_AFR_Lookup[temp_byte] & 0x0F] | heater_dot;
 055A 5202              mov A,[X+2]
 055C 5300              mov [__r1],A
 055E 550000            mov [__r0],0
 0561 06009E            add [__r1],<_ip_to_AFR_Lookup
 0564 0E009E            adc [__r0],>_ip_to_AFR_Lookup
 0567 5100              mov A,[__r0]
 0569 10                push X
 056A 5800              mov X,[__r1]
 056C 28                romx
 056D 20                pop X
 056E 5300              mov [__r1],A
 0570 550000            mov [__r0],0
 0573 26000F            and [__r1],15
 0576 260000            and [__r0],0
 0579 06003C            add [__r1],<_digitToSegment
 057C 0E003C            adc [__r0],>_digitToSegment
 057F 5100              mov A,[__r0]
 0581 10                push X
 0582 5800              mov X,[__r1]
 0584 28                romx
 0585 20                pop X
 0586 5300              mov [__r0],A
 0588 2B0B              or A,[X+11]
 058A 5404              mov [X+4],A
 058C                   .dbline 732
 058C           ;                               
 058C           ;                                       TM1637_setSegments(digits, 2, 2);
 058C 5002              mov A,2
 058E 08                push A
 058F 08                push A
 0590 5A00              mov [__r1],X
 0592 060003            add [__r1],3
 0595 5100              mov A,[__r0]
 0597 08                push A
 0598 5100              mov A,[__r1]
 059A 08                push A
 059B 909C              xcall _TM1637_setSegments
 059D 38FC              add SP,-4
 059F                   .dbline 785
 059F           ;                               #endif
 059F           ;                       #endif
 059F           ;                       
 059F           ;                       #ifdef LED_Lambda
 059F           ;                               temp_int=ip-ip_to_LambdaD_Lookup_Start; 
 059F           ;                               if (temp_int<0)
 059F           ;                               {
 059F           ;                                       temp_int=0;
 059F           ;                               }
 059F           ;                               if (temp_int>(ip_to_LambdaD_Lookup_Size-1))
 059F           ;                               {
 059F           ;                                       temp_int=(ip_to_LambdaD_Lookup_Size-1);
 059F           ;                               }
 059F           ;                               temp_byte = temp_int;   // code size optimization
 059F           ;                               
 059F           ;                               #ifdef LED_AFR
 059F           ;                                       if ((SWPORT & SWPIN) != 0)
 059F           ;                                       {
 059F           ;                                               // Lambda int part, add dot
 059F           ;                                               if (temp_byte < 120)    // 120th value is equal to lambda 1.00
 059F           ;                                                       digits[0] = digitToSegment[0] | 0x80;
 059F           ;                                               else
 059F           ;                                                       digits[0] = digitToSegment[1] | 0x80;
 059F           ;                                       
 059F           ;                                               // Lambda 0.x0 part
 059F           ;                                               digits[1] = digitToSegment[(ip_to_Lambda_Lookup[temp_byte] & 0xF0) >> 4];
 059F           ;                                       
 059F           ;                                               // Lambda 0.0x part, far right decimal point blinking indicates sensor heating
 059F           ;                                               digits[2] = digitToSegment[ip_to_Lambda_Lookup[temp_byte] & 0x0F] | heater_dot;
 059F           ;                                                       
 059F           ;                                               TM1637_setSegments(digits, 3, 1);
 059F           ;                                       }
 059F           ;                               #else
 059F           ;                                       // Lambda int part, add dot
 059F           ;                                       if (temp_byte < 120)    // 120th value is equal to lambda 1.00
 059F           ;                                               digits[0] = digitToSegment[0] | 0x80;
 059F           ;                                       else
 059F           ;                                               digits[0] = digitToSegment[1] | 0x80;
 059F           ;                                       
 059F           ;                                       // Lambda 0.x0 part
 059F           ;                                       digits[1] = digitToSegment[(ip_to_Lambda_Lookup[temp_byte] & 0xF0) >> 4];
 059F           ;                                       
 059F           ;                                       // Lambda 0.0x part, far right decimal point blinking indicates sensor heating
 059F           ;                                       digits[2] = digitToSegment[ip_to_Lambda_Lookup[temp_byte] & 0x0F] | heater_dot;
 059F           ;                                                                               
 059F           ;                                       TM1637_setSegments(digits, 3, 1);
 059F           ;                               #endif
 059F           ;                       #endif
 059F           ;                       
 059F           ;                       #if defined LED_Heater_dot && (defined LED_AFR || defined LED_Lambda)
 059F           ;                               // proof of concept for temperature below target indication, 175 should mean 750*C
 059F           ;                               // ToDo: disabling dot once target is achieved
 059F           ;                               if (Ri_Delta>175)
 059F 50AF              mov A,-81
 05A1 121C              sub A,[_Ri_Delta+1]
 05A3 511B              mov A,[_Ri_Delta]
 05A5 3180              xor A,-128
 05A7 5300              mov [__rX],A
 05A9 5080              mov A,(0 ^ 0x80)
 05AB 1A00              sbb A,[__rX]
 05AD D004              jnc L63
 05AF           X37:
 05AF                   .dbline 787
 05AF           ;                               {
 05AF           ;                                       heater_dot ^= 0x80;
 05AF                   .dbline 787
 05AF 370B80            xor [X+11],-128
 05B2                   .dbline 788
 05B2           ;                               }
 05B2           L63:
 05B2                   .dbline 793
 05B2           ;                       #endif
 05B2           ;                       
 05B2           ;                       #ifdef LED_Dimmer
 05B2           ;                               // Brightness control
 05B2           ;                               if ((BRPORT & BRPIN) != 0)                                      // pin high -> headlights on
 05B2 5D04              mov A,REG[0x4]
 05B4 5300              mov [__r0],A
 05B6 470008            tst [__r0],8
 05B9 A006              jz L65
 05BB                   .dbline 794
 05BB           ;                                       m_brightness = LED_BR_LOW | LED_ON;             // reduced brightnes 
 05BB 55000A            mov [_m_brightness],10
 05BE 8004              xjmp L66
 05C0           L65:
 05C0                   .dbline 796
 05C0           ;                               else
 05C0           ;                                       m_brightness = LED_BR_HIGH | LED_ON;    // normal brightnes
 05C0 55000D            mov [_m_brightness],13
 05C3           L66:
 05C3                   .dbline 798
 05C3           ;                       #endif
 05C3           ;               }
 05C3           L56:
 05C3                   .dbline 799
 05C3           ;               if (Heatup_Heater_Output<255)
 05C3 3C05FF            cmp [_Heatup_Heater_Output],-1
 05C6 DD76              jnc L32
 05C8           X38:
 05C8                   .dbline 801
 05C8           ;               {   
 05C8           ;                       if (Heatup_Counter>Heatup_Counter_Set)
 05C8                   .dbline 801
 05C8 5064              mov A,100
 05CA 3A0A              cmp A,[_Heatup_Counter]
 05CC D006              jnc L69
 05CE           X39:
 05CE                   .dbline 803
 05CE           ;                       {
 05CE           ;                               Heatup_Counter=0;
 05CE                   .dbline 803
 05CE 550A00            mov [_Heatup_Counter],0
 05D1                   .dbline 804
 05D1           ;                               Heatup_Heater_Output++;
 05D1 7605              inc [_Heatup_Heater_Output]
 05D3                   .dbline 805
 05D3           ;                       }
 05D3           L69:
 05D3                   .dbline 806
 05D3           ;                       if ((Ri_Min>50) && (Ri_Max<475) && (Ri_Delta<Ri_Delta_Target))
 05D3 5032              mov A,50
 05D5 120A              sub A,[_Ri_Min+1]
 05D7 5109              mov A,[_Ri_Min]
 05D9 3180              xor A,-128
 05DB 5300              mov [__rX],A
 05DD 5080              mov A,(0 ^ 0x80)
 05DF 1A00              sbb A,[__rX]
 05E1 DD5B              jnc L32
 05E3           X40:
 05E3 5108              mov A,[_Ri_Max+1]
 05E5 11DB              sub A,-37
 05E7 5107              mov A,[_Ri_Max]
 05E9 3180              xor A,-128
 05EB 1981              sbb A,(1 ^ 0x80)
 05ED DD4F              jnc L32
 05EF           X41:
 05EF 511C              mov A,[_Ri_Delta+1]
 05F1 118F              sub A,-113
 05F3 511B              mov A,[_Ri_Delta]
 05F5 3180              xor A,-128
 05F7 1980              sbb A,(0 ^ 0x80)
 05F9 DD43              jnc L32
 05FB           X42:
 05FB                   .dbline 808
 05FB           ;                       {
 05FB           ;                               Heatup_Heater_Output=255;
 05FB                   .dbline 808
 05FB 5505FF            mov [_Heatup_Heater_Output],-1
 05FE                   .dbline 809
 05FE           ;                               Ri_Delta_Error_Sum=0;
 05FE 550400            mov [_Ri_Delta_Error_Sum+1],0
 0601 550300            mov [_Ri_Delta_Error_Sum],0
 0604                   .dbline 810
 0604           ;                       }
 0604                   .dbline 811
 0604           ;               }
 0604                   .dbline 812
 0604           ;       }
 0604                   .dbline 500
 0604                   .dbline 500
 0604 8D38              xjmp L32
 0606           X25:
 0606                   .dbline -2
 0606           L30:
 0606 38F1              add SP,-15
 0608 20                pop X
 0609                   .dbline 0 ; func end
 0609 8FFF              jmp .
 060B                   .dbsym l temp_byte2 14 c
 060B                   .dbsym l temp_int2 12 I
 060B                   .dbsym l heater_dot 11 c
 060B                   .dbsym l temp_ulong 7 l
 060B                   .dbsym l digits 3 A[4:4]c
 060B                   .dbsym l temp_byte 2 c
 060B                   .dbsym l temp_int 0 I
 060B                   .dbend
 060B                   .dbfunc e TM1637_init _TM1637_init fV
 060B           _TM1637_init::
 060B                   .dbline -1
 060B                   .dbline 923
 060B           ; }
 060B           ; 
 060B           ; #if defined LED_AFR || defined LED_Lambda
 060B           ; // ================================================================================
 060B           ; // === TM1637 control functions ===================================================
 060B           ; // ================================================================================
 060B           ; 
 060B           ; //  Modified (heavily) for PSoC 1 CY8C24423-24 by: dstagegarage@gmail.com
 060B           ; //  Original author for Arduino: avishorp@gmail.com
 060B           ; //
 060B           ; //  This library is free software; you can redistribute it and/or
 060B           ; //  modify it under the terms of the GNU Lesser General Public
 060B           ; //  License as published by the Free Software Foundation; either
 060B           ; //  version 2.1 of the License, or (at your option) any later version.
 060B           ; //
 060B           ; //  This library is distributed in the hope that it will be useful,
 060B           ; //  but WITHOUT ANY WARRANTY; without even the implied warranty of
 060B           ; //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 060B           ; //  Lesser General Public License for more details.
 060B           ; //
 060B           ; //  You should have received a copy of the GNU Lesser General Public
 060B           ; //  License along with this library; if not, write to the Free Software
 060B           ; //  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 060B           ; 
 060B           ; // ----------------------------------------
 060B           ; #if DIO_PORT == 1
 060B           ;       #define DIOPORT PRT1DR
 060B           ;       #define DIODM2 PRT1DM2
 060B           ;       #define DIODM1 PRT1DM1
 060B           ;       #define DIODM0 PRT1DM0
 060B           ; #elif DIO_PORT == 2
 060B           ;       #define DIOPORT PRT2DR
 060B           ;       #define DIODM2 PRT2DM2
 060B           ;       #define DIODM1 PRT2DM1
 060B           ;       #define DIODM0 PRT2DM0
 060B           ; #else
 060B           ;       #define DIOPORT PRT0DR
 060B           ;       #define DIODM2 PRT0DM2
 060B           ;       #define DIODM1 PRT0DM1
 060B           ;       #define DIODM0 PRT0DM0
 060B           ; #endif
 060B           ; #if CLK_PORT == 1
 060B           ;       #define CLKPORT PRT1DR
 060B           ;       #define CLKDM2 PRT1DM2
 060B           ;       #define CLKDM1 PRT1DM1
 060B           ;       #define CLKDM0 PRT1DM0
 060B           ; #elif CLK_PORT == 2
 060B           ;       #define CLKPORT PRT2DR
 060B           ;       #define CLKDM2 PRT2DM2
 060B           ;       #define CLKDM1 PRT2DM1
 060B           ;       #define CLKDM0 PRT2DM0
 060B           ; #else
 060B           ;       #define CLKPORT PRT0DR
 060B           ;       #define CLKDM2 PRT0DM2
 060B           ;       #define CLKDM1 PRT0DM1
 060B           ;       #define CLKDM0 PRT0DM0
 060B           ; #endif
 060B           ; #define DIOPIN (1 << DIO_PIN)
 060B           ; #define CLKPIN (1 << CLK_PIN)
 060B           ; #define TM1637_CLK_L CLKPORT &= ~CLKPIN
 060B           ; #define TM1637_CLK_H CLKPORT |= CLKPIN
 060B           ; #define TM1637_DIO_L DIOPORT &= ~DIOPIN
 060B           ; #define TM1637_DIO_H DIOPORT |= DIOPIN
 060B           ; #define TM1637_DIO_READ DIOPORT & DIOPIN
 060B           ; /*#define IOPIN7      0x80
 060B           ; #define TM1637_CLK_L PRT1DR &= ~IOPIN7
 060B           ; #define TM1637_CLK_H PRT1DR |= IOPIN7
 060B           ; #define TM1637_DIO_L PRT2DR &= ~IOPIN7
 060B           ; #define TM1637_DIO_H PRT2DR |= IOPIN7
 060B           ; #define TM1637_DIO_READ PRT2DR & IOPIN7*/
 060B           ; 
 060B           ; #define BITDELAY 2
 060B           ; 
 060B           ; #define TM1637_I2C_COMM1    0x40
 060B           ; #define TM1637_I2C_COMM2    0xC0
 060B           ; #define TM1637_I2C_COMM3    0x80
 060B           ; 
 060B           ; /* moved to the top of main.c//
 060B           ; BYTE m_brightness = 0x0C;
 060B           ; 
 060B           ; //      A
 060B           ; //     ---
 060B           ; //  F |   | B
 060B           ; //     -G-
 060B           ; //  E |   | C
 060B           ; //     ---
 060B           ; //      D
 060B           ; const BYTE digitToSegment[] = {
 060B           ;  // XGFEDCBA
 060B           ;   0b00111111,    // 0
 060B           ;   0b00000110,    // 1
 060B           ;   0b01011011,    // 2
 060B           ;   0b01001111,    // 3
 060B           ;   0b01100110,    // 4
 060B           ;   0b01101101,    // 5
 060B           ;   0b01111101,    // 6
 060B           ;   0b00000111,    // 7
 060B           ;   0b01111111,    // 8
 060B           ;   0b01101111,    // 9
 060B           ;   //0b01110111,    // A
 060B           ;   //0b01111100,    // b
 060B           ;   //0b00111001,    // C
 060B           ;   //0b01011110,    // d
 060B           ;   //0b01111001,    // E
 060B           ;   //0b01110001     // F
 060B           ;   };*/
 060B           ; 
 060B           ; //static const BYTE minusSegments = 0b01000000;
 060B           ; 
 060B           ; void TM1637_init(void)
 060B           ; {
 060B                   .dbline 930
 060B           ;       // DStage DSpeed has extra pads for pins P1.7 and P2.7 and programming pins P1.0 and P1.1
 060B           ;       // DStage WBOOS has extra pads for pins P0.4, P1.2, P1.3, P1.7, P2.7, programming pins P1.0 and P1.1 and all LCD pins are free in this mode
 060B           ;       
 060B           ;       // CLK line 
 060B           ;       // 001 strong high and low; theoritically it should be resistive high strong low to allow for display response but
 060B           ;       // it requires stronger pull-up resistor most likey and was ustable in experiments, would be good to check current when ACK i aplied by the display
 060B           ;       CLKDM2 &= ~CLKPIN;
 060B 4107FD            and REG[0x7],-3
 060E                   .dbline 931
 060E           ;       CLKDM1 &= ~CLKPIN;
 060E 7110              or F,0x10  ; iopage = 1
 0610 4105FD            and REG[0x5],-3
 0613                   .dbline 932
 0613           ;       CLKDM0 |= CLKPIN;
 0613 430402            or REG[0x4],2
 0616                   .dbline 933
 0616           ;       TM1637_CLK_H;
 0616 70CF              and F,0xCF      ; iopage = 0
 0618 430402            or REG[0x4],2
 061B                   .dbline 938
 061B           ;       
 061B           ;       // DIO line
 061B           ;       // 001 strong high and low; theoritically it should be resistive high strong low to allow for display response but
 061B           ;       // it requires stronger pull-up resistor most likey and was ustable in experiments, would be good to check current when ACK i aplied by the display
 061B           ;       DIODM2 &= ~DIOPIN;
 061B 4107FE            and REG[0x7],-2
 061E                   .dbline 939
 061E           ;       DIODM1 &= ~DIOPIN;
 061E 7110              or F,0x10  ; iopage = 1
 0620 4105FE            and REG[0x5],-2
 0623                   .dbline 940
 0623           ;       DIODM0 |= DIOPIN;
 0623 430401            or REG[0x4],1
 0626                   .dbline 941
 0626           ;       TM1637_DIO_H;
 0626 70CF              and F,0xCF      ; iopage = 0
 0628 430401            or REG[0x4],1
 062B                   .dbline 955
 062B           ;       
 062B           ;       #if defined LED_AFR && defined LED_Lambda
 062B           ;               // LED AFR/Lambda switch line
 062B           ;               // 011 resistive high (pull-up), strong low -> used as input with pull-up, recommended external pull-up or direct high/low state switching
 062B           ;               SWDM2 &= ~SWPIN;
 062B           ;               SWDM1 |= SWPIN;
 062B           ;               SWDM0 |= SWPIN;
 062B           ;               SWPORT |= SWPIN;
 062B           ;       #endif
 062B           ;       
 062B           ;       #ifdef LED_Dimmer
 062B           ;               // LED brightness switch line
 062B           ;               // 010 Hi-Z high and low, digital input enabled -> used as input, use external pull-down or direct high/low state switching, experiments with 000 mode could be performed (might add internal pull-down?)
 062B           ;               BRDM2 &= ~BRPIN;
 062B 4107F7            and REG[0x7],-9
 062E                   .dbline 956
 062E           ;               BRDM1 |= BRPIN;
 062E 7110              or F,0x10  ; iopage = 1
 0630 430508            or REG[0x5],8
 0633                   .dbline 957
 0633           ;               BRDM0 &= ~BRPIN;
 0633 4104F7            and REG[0x4],-9
 0636                   .dbline -2
 0636 70CF              and F,0xCF      ; iopage = 0
 0638           L73:
 0638                   .dbline 0 ; func end
 0638 7F                ret
 0639                   .dbend
 0639                   .dbfunc e TM1637_setSegments _TM1637_setSegments fV
 0639           ;              k -> X+0
 0639           ;            pos -> X-7
 0639           ;         length -> X-6
 0639           ;       segments -> X-5
 0639           _TM1637_setSegments::
 0639                   .dbline -1
 0639 10                push X
 063A 4F                mov X,SP
 063B 3801              add SP,1
 063D                   .dbline 968
 063D           ;               //BRPORT &= ~BRPIN;
 063D           ;       #endif
 063D           ; }
 063D           ; 
 063D           ; /*void TM1637_setBrightness(BYTE brightness, BYTE on)
 063D           ; {
 063D           ;       m_brightness = (brightness & 0x7) | (on? 0x08 : 0x00);
 063D           ; }*/
 063D           ; 
 063D           ; void TM1637_setSegments(BYTE segments[], BYTE length, BYTE pos)
 063D           ; {
 063D                   .dbline 971
 063D           ;       BYTE k;
 063D           ;     // Write COMM1
 063D           ;       TM1637_start();
 063D 9045              xcall _TM1637_start
 063F                   .dbline 972
 063F           ;       TM1637_writeByte(TM1637_I2C_COMM1);
 063F 5040              mov A,64
 0641 08                push A
 0642 906A              xcall _TM1637_writeByte
 0644                   .dbline 973
 0644           ;       TM1637_stop();
 0644 9049              xcall _TM1637_stop
 0646                   .dbline 976
 0646           ; 
 0646           ;       // Write COMM2 + first digit address
 0646           ;       TM1637_start();
 0646 903C              xcall _TM1637_start
 0648                   .dbline 977
 0648           ;       TM1637_writeByte(TM1637_I2C_COMM2 + (pos & 0x03));
 0648 52F9              mov A,[X-7]
 064A 2103              and A,3
 064C 01C0              add A,-64
 064E 08                push A
 064F 905D              xcall _TM1637_writeByte
 0651 38FE              add SP,-2
 0653                   .dbline 980
 0653           ; 
 0653           ;       // Write the data bytes
 0653           ;       for (k=0; k < length; k++)
 0653 560000            mov [X+0],0
 0656 8012              xjmp L78
 0658           L75:
 0658                   .dbline 981
 0658           ;         TM1637_writeByte(segments[k]);
 0658 5200              mov A,[X+0]
 065A 5300              mov [__r1],A
 065C 52FC              mov A,[X-4]
 065E 0400              add [__r1],A
 0660 3E00              mvi A,[__r1]
 0662 08                push A
 0663 9049              xcall _TM1637_writeByte
 0665 38FF              add SP,-1
 0667           L76:
 0667                   .dbline 980
 0667 7700              inc [X+0]
 0669           L78:
 0669                   .dbline 980
 0669 5200              mov A,[X+0]
 066B 3BFA              cmp A,[X-6]
 066D CFEA              jc L75
 066F           X43:
 066F                   .dbline 983
 066F           ; 
 066F           ;       TM1637_stop();
 066F 901E              xcall _TM1637_stop
 0671                   .dbline 986
 0671           ; 
 0671           ;       // Write COMM3 + brightness
 0671           ;       TM1637_start();
 0671 9011              xcall _TM1637_start
 0673                   .dbline 987
 0673           ;       TM1637_writeByte(TM1637_I2C_COMM3 + (m_brightness & 0x0f));
 0673 5100              mov A,[_m_brightness]
 0675 210F              and A,15
 0677 0180              add A,-128
 0679 08                push A
 067A 9032              xcall _TM1637_writeByte
 067C 38FF              add SP,-1
 067E                   .dbline 988
 067E           ;       TM1637_stop();
 067E 900F              xcall _TM1637_stop
 0680                   .dbline -2
 0680           L74:
 0680 38FF              add SP,-1
 0682 20                pop X
 0683                   .dbline 0 ; func end
 0683 7F                ret
 0684                   .dbsym l k 0 c
 0684                   .dbsym l pos -7 c
 0684                   .dbsym l length -6 c
 0684                   .dbsym l segments -5 pc
 0684                   .dbend
 0684                   .dbfunc e TM1637_start _TM1637_start fV
 0684           _TM1637_start::
 0684                   .dbline -1
 0684                   .dbline 1075
 0684           ; }
 0684           ; 
 0684           ; /*void TM1637_clear()
 0684           ; {
 0684           ;     BYTE data[] = { 0, 0, 0, 0 };
 0684           ;       TM1637_setSegments(data);
 0684           ; }*/
 0684           ; /*
 0684           ; void TM1637_showNumberDec(int num, BYTE leading_zero, BYTE length, BYTE pos)
 0684           ; {
 0684           ;   TM1637_showNumberDecEx(num, 0, leading_zero, length, pos);
 0684           ; }
 0684           ; 
 0684           ; void TM1637_showNumberDecEx(int num, BYTE dots, BYTE leading_zero, BYTE length, BYTE pos)
 0684           ; {
 0684           ;   TM1637_showNumberBaseEx(num < 0? -10 : 10, num < 0? -num : num, dots, leading_zero, length, pos);
 0684           ; }
 0684           ; 
 0684           ; void TM1637_showNumberHexEx(unsigned int num, BYTE dots, BYTE leading_zero, BYTE length, BYTE pos)
 0684           ; {
 0684           ;   TM1637_showNumberBaseEx(16, num, dots, leading_zero, length, pos);
 0684           ; }
 0684           ; 
 0684           ; void TM1637_showNumberBaseEx(BYTE base, unsigned int num, BYTE dots, BYTE leading_zero, BYTE length, BYTE pos)
 0684           ; {
 0684           ;       int i;
 0684           ;     BYTE negative = 0;
 0684           ;       BYTE digits[4];
 0684           ;       BYTE digit;
 0684           ;       
 0684           ;       if (base < 0) 
 0684           ;       {
 0684           ;           base = -base;
 0684           ;               negative = 1;
 0684           ;       }
 0684           ; 
 0684           ;       if (num == 0 && !leading_zero) 
 0684           ;       {
 0684           ;               // Singular case - take care separately
 0684           ;               for(i = 0; i < (length-1); i++)
 0684           ;                       digits[i] = 0;
 0684           ;               digits[length-1] = TM1637_encodeDigit(0);
 0684           ;       }
 0684           ;       else 
 0684           ;       {
 0684           ;               //uint8_t i = length-1;
 0684           ;               //if (negative) {
 0684           ;               //      // Negative number, show the minus sign
 0684           ;               //    digits[i] = minusSegments;
 0684           ;               //      i--;
 0684           ;               //}
 0684           ;               
 0684           ;               for(i = length-1; i >= 0; --i)
 0684           ;               {
 0684           ;                   digit = num % base;
 0684           ;                       
 0684           ;                       if (digit == 0 && num == 0 && leading_zero == 0)
 0684           ;                           // Leading zero is blank
 0684           ;                               digits[i] = 0;
 0684           ;                       else
 0684           ;                           digits[i] = TM1637_encodeDigit(digit);
 0684           ;                               
 0684           ;                       if (digit == 0 && num == 0 && negative) 
 0684           ;                       {
 0684           ;                           digits[i] = minusSegments;
 0684           ;                               negative = 0;
 0684           ;                       }
 0684           ; 
 0684           ;                       num /= base;
 0684           ;               }
 0684           ;     }
 0684           ;       
 0684           ;       if(dots != 0)
 0684           ;       {
 0684           ;               TM1637_showDots(dots, digits);
 0684           ;       }
 0684           ;     
 0684           ;     TM1637_setSegments(digits, length, pos);
 0684           ; }
 0684           ; */
 0684           ; /*void TM1637_LCD_Delay50uTimes(BITDELAY)
 0684           ; {
 0684           ;       TM1637_delayMicroseconds(m_bitDelay);
 0684           ; }*/
 0684           ; 
 0684           ; void TM1637_start(void)
 0684           ; {
 0684                   .dbline 1076
 0684           ;   TM1637_DIO_L;
 0684 4104FE            and REG[0x4],-2
 0687                   .dbline 1077
 0687           ;   LCD_Delay50uTimes(BITDELAY);
 0687 10                push X
 0688 5002              mov A,2
 068A 7C0000            xcall _LCD_Delay50uTimes
 068D 20                pop X
 068E                   .dbline -2
 068E           L79:
 068E                   .dbline 0 ; func end
 068E 7F                ret
 068F                   .dbend
 068F                   .dbfunc e TM1637_stop _TM1637_stop fV
 068F           _TM1637_stop::
 068F                   .dbline -1
 068F                   .dbline 1081
 068F           ; }
 068F           ; 
 068F           ; void TM1637_stop(void)
 068F           ; {
 068F                   .dbline 1082
 068F           ;       TM1637_DIO_L;
 068F 4104FE            and REG[0x4],-2
 0692                   .dbline 1083
 0692           ;       LCD_Delay50uTimes(BITDELAY);
 0692 10                push X
 0693 5002              mov A,2
 0695 7C0000            xcall _LCD_Delay50uTimes
 0698 20                pop X
 0699                   .dbline 1084
 0699           ;       TM1637_CLK_H;
 0699 430402            or REG[0x4],2
 069C                   .dbline 1085
 069C           ;       LCD_Delay50uTimes(BITDELAY);
 069C 10                push X
 069D 5002              mov A,2
 069F 7C0000            xcall _LCD_Delay50uTimes
 06A2 20                pop X
 06A3                   .dbline 1086
 06A3           ;       TM1637_DIO_H;
 06A3 430401            or REG[0x4],1
 06A6                   .dbline 1087
 06A6           ;       LCD_Delay50uTimes(BITDELAY);
 06A6 10                push X
 06A7 5002              mov A,2
 06A9 7C0000            xcall _LCD_Delay50uTimes
 06AC 20                pop X
 06AD                   .dbline -2
 06AD           L80:
 06AD                   .dbline 0 ; func end
 06AD 7F                ret
 06AE                   .dbend
 06AE                   .dbfunc e TM1637_writeByte _TM1637_writeByte fc
 06AE           ;            ack -> X+2
 06AE           ;              i -> X+1
 06AE           ;           data -> X+0
 06AE           ;              b -> X-4
 06AE           _TM1637_writeByte::
 06AE                   .dbline -1
 06AE 10                push X
 06AF 4F                mov X,SP
 06B0 3803              add SP,3
 06B2                   .dbline 1091
 06B2           ; }
 06B2           ; 
 06B2           ; BYTE TM1637_writeByte(BYTE b)
 06B2           ; {
 06B2                   .dbline 1092
 06B2           ;   BYTE data = b;
 06B2 52FC              mov A,[X-4]
 06B4 5400              mov [X+0],A
 06B6                   .dbline 1096
 06B6           ;   BYTE i, ack;
 06B6           ; 
 06B6           ;   // 8 Data Bits
 06B6           ;   for(i = 0; i < 8; i++) {
 06B6 560100            mov [X+1],0
 06B9 802F              xjmp L85
 06BB           L82:
 06BB                   .dbline 1096
 06BB                   .dbline 1098
 06BB           ;     // CLK low
 06BB           ;     TM1637_CLK_L;
 06BB 4104FD            and REG[0x4],-3
 06BE                   .dbline 1099
 06BE           ;     LCD_Delay50uTimes(BITDELAY);
 06BE 10                push X
 06BF 5002              mov A,2
 06C1 7C0000            xcall _LCD_Delay50uTimes
 06C4 20                pop X
 06C5                   .dbline 1102
 06C5           ; 
 06C5           ;       // Set data bit
 06C5           ;     if (data & 0x01)
 06C5 480001            tst [X+0],1
 06C8 A006              jz L86
 06CA                   .dbline 1103
 06CA           ;       TM1637_DIO_H;
 06CA 430401            or REG[0x4],1
 06CD 8004              xjmp L87
 06CF           L86:
 06CF                   .dbline 1105
 06CF           ;     else
 06CF           ;       TM1637_DIO_L;
 06CF 4104FE            and REG[0x4],-2
 06D2           L87:
 06D2                   .dbline 1107
 06D2           ; 
 06D2           ;     LCD_Delay50uTimes(BITDELAY);
 06D2 10                push X
 06D3 5002              mov A,2
 06D5 7C0000            xcall _LCD_Delay50uTimes
 06D8 20                pop X
 06D9                   .dbline 1110
 06D9           ; 
 06D9           ;       // CLK high
 06D9           ;     TM1637_CLK_H;
 06D9 430402            or REG[0x4],2
 06DC                   .dbline 1111
 06DC           ;     LCD_Delay50uTimes(BITDELAY);
 06DC 10                push X
 06DD 5002              mov A,2
 06DF 7C0000            xcall _LCD_Delay50uTimes
 06E2 20                pop X
 06E3                   .dbline 1112
 06E3           ;     data = data >> 1;
 06E3 70FB              and F,-5
 06E5 6F00              rrc [X+0]
 06E7                   .dbline 1113
 06E7           ;   }
 06E7           L83:
 06E7                   .dbline 1096
 06E7 7701              inc [X+1]
 06E9           L85:
 06E9                   .dbline 1096
 06E9 3D0108            cmp [X+1],8
 06EC CFCE              jc L82
 06EE           X44:
 06EE                   .dbline 1117
 06EE           ; 
 06EE           ;   // Wait for acknowledge
 06EE           ;   // CLK to zero
 06EE           ;   TM1637_CLK_L;
 06EE 4104FD            and REG[0x4],-3
 06F1                   .dbline 1118
 06F1           ;   TM1637_DIO_H;
 06F1 430401            or REG[0x4],1
 06F4                   .dbline 1119
 06F4           ;   LCD_Delay50uTimes(BITDELAY);
 06F4 10                push X
 06F5 5002              mov A,2
 06F7 7C0000            xcall _LCD_Delay50uTimes
 06FA 20                pop X
 06FB                   .dbline 1122
 06FB           ; 
 06FB           ;   // CLK to high
 06FB           ;   TM1637_CLK_H;
 06FB 430402            or REG[0x4],2
 06FE                   .dbline 1123
 06FE           ;   LCD_Delay50uTimes(BITDELAY);
 06FE 10                push X
 06FF 5002              mov A,2
 0701 7C0000            xcall _LCD_Delay50uTimes
 0704 20                pop X
 0705                   .dbline 1124
 0705           ;   ack = TM1637_DIO_READ; //digitalRead(m_pinDIO);
 0705 5D04              mov A,REG[0x4]
 0707 2101              and A,1
 0709 5402              mov [X+2],A
 070B                   .dbline 1125
 070B           ;   if (ack == 0)
 070B 3D0200            cmp [X+2],0
 070E B004              jnz L88
 0710                   .dbline 1126
 0710           ;     TM1637_DIO_L;
 0710 4104FE            and REG[0x4],-2
 0713           L88:
 0713                   .dbline 1128
 0713           ; 
 0713           ;   LCD_Delay50uTimes(BITDELAY);
 0713 10                push X
 0714 5002              mov A,2
 0716 7C0000            xcall _LCD_Delay50uTimes
 0719 20                pop X
 071A                   .dbline 1129
 071A           ;   TM1637_CLK_L;
 071A 4104FD            and REG[0x4],-3
 071D                   .dbline 1130
 071D           ;   LCD_Delay50uTimes(BITDELAY);
 071D 10                push X
 071E 5002              mov A,2
 0720 7C0000            xcall _LCD_Delay50uTimes
 0723 20                pop X
 0724                   .dbline 1132
 0724           ;   
 0724           ;   if (ack == 0)
 0724 3D0200            cmp [X+2],0
 0727 B005              jnz L90
 0729                   .dbline 1133
 0729           ;       return 0;
 0729 5000              mov A,0
 072B 8003              xjmp L81
 072D           L90:
 072D                   .dbline 1135
 072D           ;   else
 072D           ;     return 1;
 072D 5001              mov A,1
 072F                   .dbline -2
 072F           L81:
 072F 38FD              add SP,-3
 0731 20                pop X
 0732                   .dbline 0 ; func end
 0732 7F                ret
 0733                   .dbsym l ack 2 c
 0733                   .dbsym l i 1 c
 0733                   .dbsym l data 0 c
 0733                   .dbsym l b -4 c
 0733                   .dbend
                        .area bss(ram, con, rel)
 0000                   .dbfile I:\PSOCDO~1\WBOOS_~2\DSTAGE~1\DSTAGE~1\main.c
 0000           _LSU_Temperature_C::
 0000                   .blkb 2
 0002                   .dbsym e LSU_Temperature_C _LSU_Temperature_C I
 0002           _Lambda_x100::
 0002                   .blkb 1
 0003                   .dbsym e Lambda_x100 _Lambda_x100 c
 0003           _ip_Justified::
 0003                   .blkb 2
 0005                   .dbsym e ip_Justified _ip_Justified I
 0005           _ip::
 0005                   .blkb 2
 0007                   .dbsym e ip _ip I
 0007           _Ri_Max::
 0007                   .blkb 2
 0009                   .dbsym e Ri_Max _Ri_Max I
 0009           _Ri_Min::
 0009                   .blkb 2
 000B                   .dbsym e Ri_Min _Ri_Min I
 000B           _Ia_Iout::
 000B                   .blkb 2
 000D                   .dbsym e Ia_Iout _Ia_Iout I
 000D           _Ia_Pout::
 000D                   .blkb 2
 000F                   .dbsym e Ia_Pout _Ia_Pout I
 000F           _Ia_Output::
 000F                   .blkb 2
 0011                   .dbsym e Ia_Output _Ia_Output I
 0011           _Ri_Mid_Error::
 0011                   .blkb 2
 0013                   .dbsym e Ri_Mid_Error _Ri_Mid_Error I
 0013           _Heater_Iout::
 0013                   .blkb 2
 0015                   .dbsym e Heater_Iout _Heater_Iout I
 0015           _Heater_Pout::
 0015                   .blkb 2
 0017                   .dbsym e Heater_Pout _Heater_Pout I
 0017           _Heater_Output::
 0017                   .blkb 2
 0019                   .dbsym e Heater_Output _Heater_Output I
 0019           _Ri_Delta_Error::
 0019                   .blkb 2
 001B                   .dbsym e Ri_Delta_Error _Ri_Delta_Error I
 001B           _Ri_Delta::
 001B                   .blkb 2
 001D                   .dbsym e Ri_Delta _Ri_Delta I
 001D           _Ri_Mid::
 001D                   .blkb 2
 001F                   .dbsym e Ri_Mid _Ri_Mid I
