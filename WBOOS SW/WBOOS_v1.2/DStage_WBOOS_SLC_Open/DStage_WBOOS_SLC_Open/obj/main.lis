                        .module main.c
                        .area text(rom, con, rel)
 0000                   .dbfile ./main.c
                        .area lit(rom, con, rel, lit)
 0000           _ip_to_Vout_Lookup::
 0000 0001              .byte 0,1
 0002 0102              .byte 1,2
 0004 0304              .byte 3,4
 0006 0405              .byte 4,5
 0008 0607              .byte 6,7
 000A 0808              .byte 8,8
 000C 090A              .byte 9,10
 000E 0B0C              .byte 11,12
 0010 0C0D              .byte 12,13
 0012 0E0F              .byte 14,15
 0014 1011              .byte 16,17
 0016 1112              .byte 17,18
 0018 1314              .byte 19,20
 001A 1516              .byte 21,22
 001C 1617              .byte 22,23
 001E 1819              .byte 24,25
 0020 1A1B              .byte 26,27
 0022 1B1C              .byte 27,28
 0024 1D1E              .byte 29,30
 0026 1F20              .byte 31,32
 0028 2122              .byte 33,34
 002A 2223              .byte 34,35
 002C 2425              .byte 36,37
 002E 2627              .byte 38,39
 0030 2829              .byte 40,41
 0032 2A2B              .byte 42,43
 0034 2C2C              .byte 44,44
 0036 2D2E              .byte 45,46
 0038 2F30              .byte 47,48
 003A 3132              .byte 49,50
 003C 3334              .byte 51,52
 003E 3536              .byte 53,54
 0040 3738              .byte 55,56
 0042 393A              .byte 57,58
 0044 3B3C              .byte 59,60
 0046 3D3E              .byte 61,62
 0048 3F40              .byte 63,64
 004A 4142              .byte 'A,'B
 004C 4344              .byte 'C,'D
 004E 4546              .byte 'E,'F
 0050 4748              .byte 'G,'H
 0052 494A              .byte 'I,'J
 0054 4C4D              .byte 'L,'M
 0056 4E4F              .byte 'N,'O
 0058 5051              .byte 'P,'Q
 005A 5253              .byte 'R,'S
 005C 5456              .byte 'T,'V
 005E 5758              .byte 'W,'X
 0060 595A              .byte 'Y,'Z
 0062 5B5C              .byte 91,92
 0064 5E5F              .byte 94,95
 0066 6061              .byte 96,'a
 0068 6264              .byte 'b,'d
 006A 6566              .byte 'e,'f
 006C 6769              .byte 'g,'i
 006E 6A6B              .byte 'j,'k
 0070 6C6E              .byte 'l,'n
 0072 6F70              .byte 'o,'p
 0074 7173              .byte 'q,'s
 0076 7475              .byte 't,'u
 0078 7778              .byte 'w,'x
 007A 7B7E              .byte 123,126
 007C 8184              .byte 129,132
 007E 878A              .byte 135,138
 0080 8D90              .byte 141,144
 0082 9397              .byte 147,151
 0084 9A9D              .byte 154,157
 0086 A1A4              .byte 161,164
 0088 A8AB              .byte 168,171
 008A AFB2              .byte 175,178
 008C B6BA              .byte 182,186
 008E BEC2              .byte 190,194
 0090 C5C9              .byte 197,201
 0092 CED2              .byte 206,210
 0094 D6DA              .byte 214,218
 0096 DEE3              .byte 222,227
 0098 E7EC              .byte 231,236
 009A F0F5              .byte 240,245
 009C FAFF              .byte 250,255
 009E                   .dbfile I:\PSOCDO~1\WBOOS_~2\DSTAGE~1\DSTAGE~1\main.c
 009E                   .dbsym e ip_to_Vout_Lookup _ip_to_Vout_Lookup A[158:158]kc
 009E           _ip_to_AFR_Lookup::
 009E FC00              .byte 252,0
 00A0 0001              .byte 0,1
 00A2 0102              .byte 1,2
 00A4 0202              .byte 2,2
 00A6 0203              .byte 2,3
 00A8 0303              .byte 3,3
 00AA 0404              .byte 4,4
 00AC 0405              .byte 4,5
 00AE 0505              .byte 5,5
 00B0 0506              .byte 5,6
 00B2 0607              .byte 6,7
 00B4 0707              .byte 7,7
 00B6 0708              .byte 7,8
 00B8 0809              .byte 8,9
 00BA 0909              .byte 9,9
 00BC 0910              .byte 9,16
 00BE 1011              .byte 16,17
 00C0 1111              .byte 17,17
 00C2 1212              .byte 18,18
 00C4 1213              .byte 18,19
 00C6 1313              .byte 19,19
 00C8 1314              .byte 19,20
 00CA 1415              .byte 20,21
 00CC 1515              .byte 21,21
 00CE 1616              .byte 22,22
 00D0 1617              .byte 22,23
 00D2 1717              .byte 23,23
 00D4 1818              .byte 24,24
 00D6 1819              .byte 24,25
 00D8 1920              .byte 25,32
 00DA 2020              .byte 32,32
 00DC 2121              .byte 33,33
 00DE 2222              .byte 34,34
 00E0 2223              .byte 34,35
 00E2 2324              .byte 35,36
 00E4 2424              .byte 36,36
 00E6 2525              .byte 37,37
 00E8 2526              .byte 37,38
 00EA 2627              .byte 38,39
 00EC 2727              .byte 39,39
 00EE 2828              .byte 40,40
 00F0 2929              .byte 41,41
 00F2 3030              .byte 48,48
 00F4 3131              .byte 49,49
 00F6 3132              .byte 49,50
 00F8 3233              .byte 50,51
 00FA 3334              .byte 51,52
 00FC 3435              .byte 52,53
 00FE 3535              .byte 53,53
 0100 3636              .byte 54,54
 0102 3737              .byte 55,55
 0104 3838              .byte 56,56
 0106 3839              .byte 56,57
 0108 4040              .byte 64,64
 010A 4041              .byte 64,'A
 010C 4242              .byte 'B,'B
 010E 4243              .byte 'B,'C
 0110 4444              .byte 'D,'D
 0112 4445              .byte 'D,'E
 0114 4546              .byte 'E,'F
 0116 4747              .byte 'G,'G
 0118 4849              .byte 'H,'I
 011A 5152              .byte 'Q,'R
 011C 5354              .byte 'S,'T
 011E 5556              .byte 'U,'V
 0120 5859              .byte 'X,'Y
 0122 6062              .byte 96,'b
 0124 6364              .byte 'c,'d
 0126 6667              .byte 'f,'g
 0128 6970              .byte 'i,'p
 012A 7173              .byte 'q,'s
 012C 7576              .byte 'u,'v
 012E 7779              .byte 'w,'y
 0130 8182              .byte 129,130
 0132 8485              .byte 132,133
 0134 8789              .byte 135,137
 0136 9193              .byte 145,147
 0138 9496              .byte 148,150
 013A 98FE              .byte 152,254
 013C                   .dbsym e ip_to_AFR_Lookup _ip_to_AFR_Lookup A[158:158]kc
 013C           _ip_to_Lambda_Lookup::
 013C FC68              .byte 252,'h
 013E 6869              .byte 'h,'i
 0140 6969              .byte 'i,'i
 0142 6969              .byte 'i,'i
 0144 7070              .byte 'p,'p
 0146 7070              .byte 'p,'p
 0148 7071              .byte 'p,'q
 014A 7171              .byte 'q,'q
 014C 7172              .byte 'q,'r
 014E 7272              .byte 'r,'r
 0150 7272              .byte 'r,'r
 0152 7373              .byte 's,'s
 0154 7373              .byte 's,'s
 0156 7474              .byte 't,'t
 0158 7474              .byte 't,'t
 015A 7475              .byte 't,'u
 015C 7575              .byte 'u,'u
 015E 7576              .byte 'u,'v
 0160 7676              .byte 'v,'v
 0162 7676              .byte 'v,'v
 0164 7777              .byte 'w,'w
 0166 7777              .byte 'w,'w
 0168 7878              .byte 'x,'x
 016A 7878              .byte 'x,'x
 016C 7979              .byte 'y,'y
 016E 7979              .byte 'y,'y
 0170 8080              .byte 128,128
 0172 8080              .byte 128,128
 0174 8181              .byte 129,129
 0176 8181              .byte 129,129
 0178 8282              .byte 130,130
 017A 8282              .byte 130,130
 017C 8383              .byte 131,131
 017E 8383              .byte 131,131
 0180 8484              .byte 132,132
 0182 8485              .byte 132,133
 0184 8585              .byte 133,133
 0186 8586              .byte 133,134
 0188 8686              .byte 134,134
 018A 8687              .byte 134,135
 018C 8787              .byte 135,135
 018E 8888              .byte 136,136
 0190 8888              .byte 136,136
 0192 8989              .byte 137,137
 0194 8990              .byte 137,144
 0196 9090              .byte 144,144
 0198 9191              .byte 145,145
 019A 9191              .byte 145,145
 019C 9292              .byte 146,146
 019E 9293              .byte 146,147
 01A0 9393              .byte 147,147
 01A2 9494              .byte 148,148
 01A4 9495              .byte 148,149
 01A6 9595              .byte 149,149
 01A8 9696              .byte 150,150
 01AA 9697              .byte 150,151
 01AC 9797              .byte 151,151
 01AE 9898              .byte 152,152
 01B0 9899              .byte 152,153
 01B2 9999              .byte 153,153
 01B4 0000              .byte 0,0
 01B6 0102              .byte 1,2
 01B8 0203              .byte 2,3
 01BA 0405              .byte 4,5
 01BC 0606              .byte 6,6
 01BE 0708              .byte 7,8
 01C0 0910              .byte 9,16
 01C2 1112              .byte 17,18
 01C4 1314              .byte 19,20
 01C6 1516              .byte 21,22
 01C8 1718              .byte 23,24
 01CA 1920              .byte 25,32
 01CC 2122              .byte 33,34
 01CE 2324              .byte 35,36
 01D0 2526              .byte 37,38
 01D2 2728              .byte 39,40
 01D4 3031              .byte 48,49
 01D6 3233              .byte 50,51
 01D8 35FE              .byte 53,254
 01DA                   .dbsym e ip_to_Lambda_Lookup _ip_to_Lambda_Lookup A[158:158]kc
 01DA           _digitToSegment::
 01DA 3F06              .byte 63,6
 01DC 5B4F              .byte 91,'O
 01DE 666D              .byte 'f,'m
 01E0 7D07              .byte 125,7
 01E2 7F6F              .byte 127,'o
 01E4                   .dbsym e digitToSegment _digitToSegment A[10:10]kc
                        .area data(ram, con, rel)
 0000                   .dbfile I:\PSOCDO~1\WBOOS_~2\DSTAGE~1\DSTAGE~1\main.c
 0000           _Ri_Mid_Error_Sum::
 0000                   .blkb 2
                        .area idata(rom,lit)
 0000 0000              .word 0
                        .area data(ram, con, rel)
 0002                   .dbfile I:\PSOCDO~1\WBOOS_~2\DSTAGE~1\DSTAGE~1\main.c
 0002                   .dbsym e Ri_Mid_Error_Sum _Ri_Mid_Error_Sum I
 0002           _Ri_Delta_Error_Sum::
 0002                   .blkb 2
                        .area idata(rom,lit)
 0002 0000              .word 0
                        .area data(ram, con, rel)
 0004                   .dbfile I:\PSOCDO~1\WBOOS_~2\DSTAGE~1\DSTAGE~1\main.c
 0004                   .dbsym e Ri_Delta_Error_Sum _Ri_Delta_Error_Sum I
 0004           _Heatup_Heater_Output::
 0004                   .blkb 1
                        .area idata(rom,lit)
 0004 64                .byte 100
                        .area data(ram, con, rel)
 0005                   .dbfile I:\PSOCDO~1\WBOOS_~2\DSTAGE~1\DSTAGE~1\main.c
 0005                   .dbsym e Heatup_Heater_Output _Heatup_Heater_Output c
                        .area text(rom, con, rel)
 0000                   .dbfile I:\PSOCDO~1\WBOOS_~2\DSTAGE~1\DSTAGE~1\main.c
 0000                   .dbfunc e Heater_PID _Heater_PID fV
 0000           _Heater_PID::
 0000                   .dbline -1
 0000                   .dbline 238
 0000           ; // =========================================================================================
 0000           ; // === DStage WBOOS - SLC Free tribute =====================================================
 0000           ; // =========================================================================================
 0000           ; // This program is a heavily modified version of the 
 0000           ; // 14point7 SLC Free open wideband oxygen sensor controller
 0000           ; //
 0000           ; // Version 1.2.0 2025.02.02
 0000           ; // 
 0000           ; // email: dstagegarage@gmail.com
 0000           ; // YT: www.youtube.com/DStageGarage
 0000           ; // GitHub: https://github.com/DStageGarage/WBOOS/
 0000           ; // =========================================================================================
 0000           ; 
 0000           ; //----------------------------------------------------------------------------
 0000           ; // C main line
 0000           ; //----------------------------------------------------------------------------
 0000           ; #include <m8c.h>        // part specific constants and macros
 0000           ; #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
 0000           ; extern BYTE ADC_Counter; //Variable Declared in ADCININT.asm
 0000           ; extern BYTE Ri_Max_x1; //Variable Declared in ADCININT.asm
 0000           ; extern BYTE Ri_Min_x1; //Variable Declared in ADCININT.asm
 0000           ; extern BYTE ip_x1; //Variable Declared in ADCININT.asm
 0000           ; extern BYTE ADC_IF; //Variable Declared in ADCININT.asm
 0000           ; extern BYTE Sleep_Counter; //Variable Declared in SleepTimerINT.asm
 0000           ; 
 0000           ; #define Vout_Lookup_Counter_Set 25
 0000           ; 
 0000           ; //============================================
 0000           ; // Configure system here
 0000           ; //============================================
 0000           ; // set how often display gets refreshed, 50 is a default value meaning roughly 50x2ms=100ms or 10 times per second
 0000           ; #define LCD_Counter_Set 50
 0000           ; 
 0000           ; // define outout signal, Lin_Out (wide band) and NB_Out (narrow band) can be both present at once
 0000           ; #define Lin_Out
 0000           ; #define NB_Out
 0000           ; 
 0000           ; // define display type and content following these guidlines:
 0000           ; //   - LCD Lmbda/AFR digits cannot be used at the same time
 0000           ; //   - LCD Lambda/Temperature Graph cannot be used at the same time
 0000           ; //   - LCD Temperature digits can be used together with Lambda/AFR digits
 0000           ; //   - LED and LCD cannot be used at the same time
 0000           ; //   - LED AFR and Lambda can be used at the same time and switched with a pin
 0000           ; //   - comment out #define for unused options
 0000           ; // #define LCD_Lambda_Graph
 0000           ; //#define LCD_AFR_digits
 0000           ; // #define LCD_Lambda_digits
 0000           ; //#define LCD_Temperature_Graph
 0000           ; // #define LCD_Temperature_digits
 0000           ; //#define DStage_logo
 0000           ; #define LED_AFR
 0000           ; #define LED_Lambda
 0000           ; 
 0000           ; // Define port/pin for LED display controller TM1637
 0000           ; #define DIO_PORT 1
 0000           ; #define DIO_PIN 0
 0000           ; #define CLK_PORT 1
 0000           ; #define CLK_PIN 1
 0000           ; #define SWITCH_PORT 1
 0000           ; #define SWITCH_PIN 7
 0000           ; 
 0000           ; /*#define DIO_PORT 2
 0000           ; #define DIO_PIN 7
 0000           ; #define CLK_PORT 1
 0000           ; #define CLK_PIN 7
 0000           ; #define SWITCH_PORT 1
 0000           ; #define SWITCH_PIN 1*/
 0000           ; //============================================
 0000           ; 
 0000           ; #define SWPIN (1 << SWITCH_PIN)
 0000           ; #if SWITCH_PORT == 1
 0000           ;       #define SWPORT PRT1DR
 0000           ;       #define SWDM2 PRT1DM2
 0000           ;       #define SWDM1 PRT1DM1
 0000           ;       #define SWDM0 PRT1DM0
 0000           ; #elif SWITCH_PORT == 2
 0000           ;       #define SWPORT PRT2DR
 0000           ;       #define SWDM2 PRT2DM2
 0000           ;       #define SWDM1 PRT2DM1
 0000           ;       #define SWDM0 PRT2DM0
 0000           ; #else
 0000           ;       #define SWPORT PRT0DR
 0000           ;       #define SWDM2 PRT0DM2
 0000           ;       #define SWDM1 PRT0DM1
 0000           ;       #define SWDM0 PRT0DM0
 0000           ; #endif
 0000           ; 
 0000           ; 
 0000           ; //#define PID_Tune
 0000           ; #define Ri_Filter_Strength 4
 0000           ; #define ip_Filter_Strength 4
 0000           ; 
 0000           ; #ifdef PID_Tune
 0000           ;       INT Ri_Mid_Target= 286;//271; //
 0000           ;       INT Ia_PID_Kp = 25; //35;
 0000           ;       INT Ia_PID_Ki = 4; //8;
 0000           ;       INT Ia_Output_Bias = 256;
 0000           ;       INT Ri_Delta_Target=143; //PID Target peak to peak Voltage of Nermest Cell
 0000           ;       INT Heater_PID_Kp =-72;
 0000           ;       INT Heater_PID_Ki =-4;
 0000           ;       INT Heater_PID_Output_Bias =128;
 0000           ; #else
 0000           ;       #define Ri_Mid_Target 286 //271 //256+14.769 = 2.53v = 2.08v(VGND) + 0.45v, PID Target Voltage of Nermest Cell
 0000           ;       #define Ia_PID_Kp 25
 0000           ;       #define Ia_PID_Ki 4
 0000           ;       #define Ia_Output_Bias 256
 0000           ;       #define Ri_Delta_Target 143 //PID Target peak to peak Voltage of Nermest Cell
 0000           ;       #define Heater_PID_Kp -72
 0000           ;       #define Heater_PID_Ki -4
 0000           ;       #define Heater_PID_Output_Bias 128
 0000           ; #endif
 0000           ; 
 0000           ; #ifdef Lin_Out
 0000           ;       #define ip_to_Vout_Lookup_Start 135
 0000           ;       #define ip_to_Vout_Lookup_Size 158
 0000           ;       const BYTE ip_to_Vout_Lookup[ip_to_Vout_Lookup_Size] = {0,1,1,2,3,4,4,5,6,7,8,8,9,10,11,12,12,13,14,15,16,17,17,18,19,20,21,22,22,23,24,25,26,27,27,28,29,30,31,32,33,34,34,35,36,37,38,39,40,41,42,43,44,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,76,77,78,79,80,81,82,83,84,86,87,88,89,90,91,92,94,95,96,97,98,100,101,102,103,105,106,107,108,110,111,112,113,115,116,117,119,120,123,126,129,132,135,138,141,144,147,151,154,157,161,164,168,171,175,178,182,186,190,194,197,201,206,210,214,218,222,227,231,236,240,245,250,255}; 
 0000           ; #endif
 0000           ; 
 0000           ; #ifdef LCD_Lambda_Graph
 0000           ;       #define ip_to_Lambda_Lookup_Start 135
 0000           ;       #define ip_to_Lambda_Lookup_Size 158
 0000           ;       const BYTE ip_to_Graph_Lookup[ip_to_Lambda_Lookup_Size]={1,8,8,9,9,9,9,9,10,10,10,10,10,11,11,11,11,12,12,12,12,12,13,13,13,13,14,14,14,14,14,15,15,15,15,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,22,22,22,22,23,23,23,23,24,24,24,25,25,25,25,26,26,26,26,27,27,27,28,28,28,28,29,29,29,30,30,30,31,31,31,31,32,32,32,33,33,33,34,34,34,35,35,35,36,36,36,37,37,37,38,38,38,39,39,39,40,40,41,42,42,43,44,45,46,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,70,71,72,73,75,80};
 0000           ;                                                                                                // lambda = 0.68  0.69      0.70           0.71        0.72           0.73        0.74           0.75        0.76           0.77        0.78        0.79        0.8         0.81        0.82           0.83     0.84     0.85        0.86        0.87     0.88        0.89     0.90     0.91        0.92     0.93     0.94     0.95     0.96     0.97     0.98     0.99     1.00
 0000           ;                                                                                                // AFR    = 10.0  10.14     10.3           10.44       10.58          10.73       10.88          11.03
 0000           ; #endif
 0000           ; 
 0000           ; #if defined LCD_AFR_digits || defined LED_AFR 
 0000           ;       #define ip_to_AFR_Lookup_Start 135
 0000           ;       #define ip_to_AFR_Lookup_Size 158
 0000           ;       const BYTE ip_to_AFR_Lookup[ip_to_AFR_Lookup_Size] = {0xFC,0x00,0x00,0x01,0x01,0x02,0x02,0x02,0x02,0x03,0x03,0x03,0x04,0x04,0x04,0x05,0x05,0x05,0x05,0x06,0x06,0x07,0x07,0x07,0x07,0x08,0x08,0x09,0x09,0x09,0x09,
 0000           ;                                                                                                                 0x10,0x10,0x11,0x11,0x11,0x12,0x12,0x12,0x13,0x13,0x13,0x13,0x14,0x14,0x15,0x15,0x15,0x16,0x16,0x16,0x17,0x17,0x17,0x18,0x18,0x18,0x19,0x19,
 0000           ;                                                                                                                 0x20,0x20,0x20,0x21,0x21,0x22,0x22,0x22,0x23,0x23,0x24,0x24,0x24,0x25,0x25,0x25,0x26,0x26,0x27,0x27,0x27,0x28,0x28,0x29,0x29,
 0000           ;                                                                                                                 0x30,0x30,0x31,0x31,0x31,0x32,0x32,0x33,0x33,0x34,0x34,0x35,0x35,0x35,0x36,0x36,0x37,0x37,0x38,0x38,0x38,0x39,
 0000           ;                                                                                                                 0x40,0x40,0x40,0x41,0x42,0x42,0x42,0x43,0x44,0x44,0x44,0x45,0x45,0x46,0x47,0x47,0x48,0x49,
 0000           ;                                                                                                                 0x51,0x52,0x53,0x54,0x55,0x56,0x58,0x59,
 0000           ;                                                                                                                 0x60,0x62,0x63,0x64,0x66,0x67,0x69,
 0000           ;                                                                                                                 0x70,0x71,0x73,0x75,0x76,0x77,0x79,
 0000           ;                                                                                                                 0x81,0x82,0x84,0x85,0x87,0x89,
 0000           ;                                                                                                                 0x91,0x93,0x94,0x96,0x98,
 0000           ;                                                                                                                 0xFE}; 
 0000           ; #endif
 0000           ; 
 0000           ; #if defined LCD_Lambda_digits || defined LED_Lambda
 0000           ;       #define ip_to_LambdaD_Lookup_Start 135
 0000           ;       #define ip_to_LambdaD_Lookup_Size 158
 0000           ;       const BYTE ip_to_Lambda_Lookup[ip_to_LambdaD_Lookup_Size]= {0xFC,0x68,0x68,0x69,0x69,0x69,0x69,0x69,
 0000           ;                                                                                                                               0x70,0x70,0x70,0x70,0x70,0x71,0x71,0x71,0x71,0x72,0x72,0x72,0x72,0x72,0x73,0x73,0x73,0x73,0x74,0x74,0x74,0x74,0x74,0x75,0x75,0x75,0x75,0x76,0x76,0x76,0x76,0x76,0x77,0x77,0x77,0x77,0x78,0x78,0x78,0x78,0x79,0x79,0x79,0x79,
 0000           ;                                                                                                                               0x80,0x80,0x80,0x80,0x81,0x81,0x81,0x81,0x82,0x82,0x82,0x82,0x83,0x83,0x83,0x83,0x84,0x84,0x84,0x85,0x85,0x85,0x85,0x86,0x86,0x86,0x86,0x87,0x87,0x87,0x88,0x88,0x88,0x88,0x89,0x89,0x89,
 0000           ;                                                                                                                               0x90,0x90,0x90,0x91,0x91,0x91,0x91,0x92,0x92,0x92,0x93,0x93,0x93,0x94,0x94,0x94,0x95,0x95,0x95,0x96,0x96,0x96,0x97,0x97,0x97,0x98,0x98,0x98,0x99,0x99,0x99,
 0000           ;                                                                                                                               0x00,0x00,0x01,0x02,0x02,0x03,0x04,0x05,0x06,0x06,0x07,0x08,0x09,
 0000           ;                                                                                                                               0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,
 0000           ;                                                                                                                               0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,
 0000           ;                                                                                                                               0x30,0x31,0x32,0x33,0x35,
 0000           ;                                                                                                                               0xFE};
 0000           ; #endif
 0000           ; 
 0000           ; #ifdef LCD_Temperature_Graph
 0000           ;       #define Ri_Delta_to_Temperature_C_Start 113
 0000           ;       #define Ri_Delta_to_Temperature_C_Size 75
 0000           ;       const BYTE Ri_Delta_to_Graph[Ri_Delta_to_Temperature_C_Size]={80,78,77,75,74,73,71,70,68,67,65,64,63,61,60,59,58,56,55,54,52,51,50,49,48,46,45,44,43,42,41,40,39,37,36,35,34,33,32,31,30,29,28,27,26,25,24,23,22,21,20,19,18,18,17,16,15,14,13,12,11,11,10,9,8,7,6,5,5,4,3,2,1,1,0};
 0000           ; #endif
 0000           ; 
 0000           ; #ifdef LCD_Temperature_digits
 0000           ;       #define Ri_Delta_to_Temperature_C_dig_Start 113
 0000           ;       #define Ri_Delta_to_Temperature_C_dig_Size 75
 0000           ;       const BYTE Ri_Delta_to_dig[Ri_Delta_to_Temperature_C_dig_Size]={0xFE,
 0000           ;                                                                                                                                       0x18,0x17,0x15,0x14,0x13,0x11,0x10,
 0000           ;                                                                                                                                       0x08,0x07,0x05,0x04,0x03,0x01,0x00,
 0000           ;                                                                                                                                       0x99,0x98,0x96,0x95,0x94,0x92,0x91,0x90,
 0000           ;                                                                                                                                       0x89,0x88,0x86,0x85,0x84,0x83,0x82,0x81,0x80,
 0000           ;                                                                                                                                       0x79,0x77,0x76,0x75,0x74,0x73,0x72,0x71,0x70,
 0000           ;                                                                                                                                       0x69,0x68,0x67,0x66,0x65,0x64,0x63,0x62,0x61,0x60,
 0000           ;                                                                                                                                       0x59,0x58,0x58,0x57,0x56,0x55,0x54,0x53,0x52,0x51,0x51,0x50,
 0000           ;                                                                                                                                       0x49,0x48,0x47,0x46,0x45,0x45,0x44,0x43,0x42,0x41,0x40,0xFC,};
 0000           ; #endif
 0000           ; 
 0000           ; #if defined LED_AFR || defined LED_Lambda
 0000           ;       void TM1637_init(void);
 0000           ;       void TM1637_setBrightness(BYTE, BYTE);
 0000           ;       void TM1637_setSegments(BYTE*, BYTE, BYTE);
 0000           ;       void TM1637_clear(void);
 0000           ;       void TM1637_showNumberDec(int, BYTE, BYTE, BYTE);
 0000           ;       void TM1637_showNumberDecEx(int, BYTE, BYTE, BYTE, BYTE);
 0000           ;       void TM1637_showNumberHexEx(unsigned int, BYTE, BYTE, BYTE, BYTE);
 0000           ;       void TM1637_showNumberBaseEx(BYTE, unsigned int, BYTE, BYTE, BYTE, BYTE);
 0000           ;       void TM1637_start(void);
 0000           ;       void TM1637_stop(void);
 0000           ;       BYTE TM1637_writeByte(BYTE);
 0000           ;       void TM1637_showDots(BYTE, BYTE*);
 0000           ;       BYTE TM1637_encodeDigit(BYTE);
 0000           ;       
 0000           ;       //      A
 0000           ;       //     ---
 0000           ;       //  F |   | B
 0000           ;       //     -G-
 0000           ;       //  E |   | C
 0000           ;       //     ---
 0000           ;       //      D
 0000           ;       const BYTE digitToSegment[] = {
 0000           ;       // XGFEDCBA
 0000           ;       0b00111111,    // 0
 0000           ;       0b00000110,    // 1
 0000           ;       0b01011011,    // 2
 0000           ;       0b01001111,    // 3
 0000           ;       0b01100110,    // 4
 0000           ;       0b01101101,    // 5
 0000           ;       0b01111101,    // 6
 0000           ;       0b00000111,    // 7
 0000           ;       0b01111111,    // 8
 0000           ;       0b01101111,    // 9
 0000           ;       //0b01110111,    // A
 0000           ;       //0b01111100,    // b
 0000           ;       //0b00111001,    // C
 0000           ;       //0b01011110,    // d
 0000           ;       //0b01111001,    // E
 0000           ;       //0b01110001     // F
 0000           ;       };
 0000           ; #endif
 0000           ; 
 0000           ; INT Ri_Mid_Error_Sum=0;
 0000           ; INT Ri_Mid;
 0000           ; INT Ri_Delta_Error_Sum=0;
 0000           ; INT Ri_Delta;
 0000           ; #define Ia_PID_Counter_Set 1
 0000           ; #define Heatup_Counter_Set 100
 0000           ; #define Heater_PID_Counter_Set 25
 0000           ; BYTE Heatup_Heater_Output=100;
 0000           ; 
 0000           ; INT Ri_Delta_Error;
 0000           ; INT Heater_Output;
 0000           ; INT Heater_Pout;
 0000           ; INT Heater_Iout;
 0000           ; 
 0000           ; //PID Controller, Input is Ri_Delta (The Peak to peak voltage on the Vs Port of the sensor) output is PWM8_Heater, PWM8_Heater is controlled such that Ri_Delta is maintained at 80 (80 =750C)
 0000           ; //Only a PI controller is used as adding the D term does not effect performance 
 0000           ; //Everything is inflated by a factor of 4 so that floating point is avioded
 0000           ; void Heater_PID(void) // Ned to run this when counter >50
 0000           ; {
 0000                   .dbline 240
 0000           ; 
 0000           ;       Ri_Delta_Error=Ri_Delta_Target-Ri_Delta;
 0000 508F              mov A,-113
 0002 121C              sub A,[_Ri_Delta+1]
 0004 531A              mov [_Ri_Delta_Error+1],A
 0006 5000              mov A,0
 0008 1A1B              sbb A,[_Ri_Delta]
 000A 5319              mov [_Ri_Delta_Error],A
 000C                   .dbline 242
 000C           ;       //Put limits on Error so PID does not go Fubar, and also so that the worst case multiplication does not overflow
 000C           ;       if (Ri_Delta_Error>(-127*16/Heater_PID_Kp))
 000C 501C              mov A,28
 000E 121A              sub A,[_Ri_Delta_Error+1]
 0010 5119              mov A,[_Ri_Delta_Error]
 0012 3180              xor A,-128
 0014 5300              mov [__rX],A
 0016 5080              mov A,(0 ^ 0x80)
 0018 1A00              sbb A,[__rX]
 001A D007              jnc L2
 001C           X0:
 001C                   .dbline 244
 001C           ;       {
 001C           ;               Ri_Delta_Error=(-127*16/Heater_PID_Kp); // -> 28, used to be 56...
 001C                   .dbline 244
 001C 551A1C            mov [_Ri_Delta_Error+1],28
 001F 551900            mov [_Ri_Delta_Error],0
 0022                   .dbline 245
 0022           ;       }
 0022           L2:
 0022                   .dbline 246
 0022           ;       if (Ri_Delta_Error<(127*16/Heater_PID_Kp))
 0022 511A              mov A,[_Ri_Delta_Error+1]
 0024 11E4              sub A,-28
 0026 5119              mov A,[_Ri_Delta_Error]
 0028 3180              xor A,-128
 002A 197F              sbb A,(-1 ^ 0x80)
 002C D007              jnc L4
 002E           X1:
 002E                   .dbline 248
 002E           ;       {
 002E           ;               Ri_Delta_Error=(127*16/Heater_PID_Kp); // -> -28, used to be -56...
 002E                   .dbline 248
 002E 551AE4            mov [_Ri_Delta_Error+1],-28
 0031 5519FF            mov [_Ri_Delta_Error],-1
 0034                   .dbline 249
 0034           ;       }
 0034           L4:
 0034                   .dbline 250
 0034           ;       Heater_Pout=(Heater_PID_Kp*Ri_Delta_Error)/16;
 0034 5F001A            mov [__r1],[_Ri_Delta_Error+1]
 0037 5F0019            mov [__r0],[_Ri_Delta_Error]
 003A 5500B8            mov [__r3],-72
 003D 5500FF            mov [__r2],-1
 0040 550000            mov [__rX],0
 0043 550000            mov [__rY],0
 0046           X2:
 0046 3C0000            cmp [__r2],0
 0049 B006              jnz X5
 004B 3C0000            cmp [__r3],0
 004E A017              jz X4
 0050           X5:
 0050 70FB              and F,-5
 0052 6E00              rrc [__r2]
 0054 6E00              rrc [__r3]
 0056 D009              jnc X3
 0058 5100              mov A,[__r1]
 005A 0400              add [__rX],A
 005C 5100              mov A,[__r0]
 005E 0C00              adc [__rY],A
 0060           X3:
 0060 6500              asl [__r1]
 0062 6B00              rlc [__r0]
 0064 8FE1              jmp X2
 0066           X4:
 0066 5F0000            mov [__r1],[__rX]
 0069 5F0000            mov [__r0],[__rY]
 006C 5000              mov A,0
 006E 08                push A
 006F 5010              mov A,16
 0071 08                push A
 0072 5100              mov A,[__r0]
 0074 08                push A
 0075 5100              mov A,[__r1]
 0077 08                push A
 0078 7C0000            xcall __divmod_16X16_16
 007B 18                pop A
 007C 5316              mov [_Heater_Pout+1],A
 007E 18                pop A
 007F 5315              mov [_Heater_Pout],A
 0081 38FE              add SP,-2
 0083                   .dbline 251
 0083           ;       Ri_Delta_Error_Sum=Ri_Delta_Error_Sum+Ri_Delta_Error;
 0083 511A              mov A,[_Ri_Delta_Error+1]
 0085 0403              add [_Ri_Delta_Error_Sum+1],A
 0087 5119              mov A,[_Ri_Delta_Error]
 0089 0C02              adc [_Ri_Delta_Error_Sum],A
 008B                   .dbline 260
 008B           ;       //If the sensor is too hot, then disreguard the Integratal contribution and just use the proportional to quickly correct the sensor temperature
 008B           ;       /*
 008B           ;       if((Ri_Delta<60)&&(Ri_Delta_Error_Sum>0))
 008B           ;       {
 008B           ;               Ri_Delta_Error_Sum=0;
 008B           ;       }
 008B           ;       */
 008B           ;       //Put limits on Error so PID does not go Fubar, and also so that the worst case multiplication does not overflow
 008B           ;       if (Ri_Delta_Error_Sum>(-127*16/Heater_PID_Ki))
 008B 50FC              mov A,-4
 008D 1203              sub A,[_Ri_Delta_Error_Sum+1]
 008F 5102              mov A,[_Ri_Delta_Error_Sum]
 0091 3180              xor A,-128
 0093 5300              mov [__rX],A
 0095 5081              mov A,(1 ^ 0x80)
 0097 1A00              sbb A,[__rX]
 0099 D007              jnc L6
 009B           X6:
 009B                   .dbline 262
 009B           ;       {
 009B           ;               Ri_Delta_Error_Sum=(-127*16/Heater_PID_Ki); // -> 508, used to be 1024...
 009B                   .dbline 262
 009B 5503FC            mov [_Ri_Delta_Error_Sum+1],-4
 009E 550201            mov [_Ri_Delta_Error_Sum],1
 00A1                   .dbline 263
 00A1           ;       }
 00A1           L6:
 00A1                   .dbline 264
 00A1           ;       if (Ri_Delta_Error_Sum<(127*16/Heater_PID_Ki))
 00A1 5103              mov A,[_Ri_Delta_Error_Sum+1]
 00A3 1104              sub A,4
 00A5 5102              mov A,[_Ri_Delta_Error_Sum]
 00A7 3180              xor A,-128
 00A9 197E              sbb A,(-2 ^ 0x80)
 00AB D007              jnc L8
 00AD           X7:
 00AD                   .dbline 266
 00AD           ;       {
 00AD           ;               Ri_Delta_Error_Sum=(127*16/Heater_PID_Ki); // -> -508, used to be -1024...
 00AD                   .dbline 266
 00AD 550304            mov [_Ri_Delta_Error_Sum+1],4
 00B0 5502FE            mov [_Ri_Delta_Error_Sum],-2
 00B3                   .dbline 267
 00B3           ;       }
 00B3           L8:
 00B3                   .dbline 268
 00B3           ;       Heater_Iout=(Heater_PID_Ki*Ri_Delta_Error_Sum)/16;
 00B3 5F0003            mov [__r1],[_Ri_Delta_Error_Sum+1]
 00B6 5F0002            mov [__r0],[_Ri_Delta_Error_Sum]
 00B9 5500FC            mov [__r3],-4
 00BC 5500FF            mov [__r2],-1
 00BF 550000            mov [__rX],0
 00C2 550000            mov [__rY],0
 00C5           X8:
 00C5 3C0000            cmp [__r2],0
 00C8 B006              jnz X11
 00CA 3C0000            cmp [__r3],0
 00CD A017              jz X10
 00CF           X11:
 00CF 70FB              and F,-5
 00D1 6E00              rrc [__r2]
 00D3 6E00              rrc [__r3]
 00D5 D009              jnc X9
 00D7 5100              mov A,[__r1]
 00D9 0400              add [__rX],A
 00DB 5100              mov A,[__r0]
 00DD 0C00              adc [__rY],A
 00DF           X9:
 00DF 6500              asl [__r1]
 00E1 6B00              rlc [__r0]
 00E3 8FE1              jmp X8
 00E5           X10:
 00E5 5F0000            mov [__r1],[__rX]
 00E8 5F0000            mov [__r0],[__rY]
 00EB 5000              mov A,0
 00ED 08                push A
 00EE 5010              mov A,16
 00F0 08                push A
 00F1 5100              mov A,[__r0]
 00F3 08                push A
 00F4 5100              mov A,[__r1]
 00F6 08                push A
 00F7 7C0000            xcall __divmod_16X16_16
 00FA 18                pop A
 00FB 5314              mov [_Heater_Iout+1],A
 00FD 18                pop A
 00FE 5313              mov [_Heater_Iout],A
 0100 38FE              add SP,-2
 0102                   .dbline 269
 0102           ;       if (Heatup_Heater_Output<255) // if Heatup_Heater_Output is < 255 that means the unit just turned on and to give control to the heatup routine
 0102 3C04FF            cmp [_Heatup_Heater_Output],-1
 0105 D009              jnc L10
 0107           X12:
 0107                   .dbline 271
 0107           ;       {
 0107           ;               Heater_Output=Heatup_Heater_Output;     
 0107                   .dbline 271
 0107 5F1804            mov [_Heater_Output+1],[_Heatup_Heater_Output]
 010A 551700            mov [_Heater_Output],0
 010D                   .dbline 272
 010D           ;       }
 010D 8019              xjmp L11
 010F           L10:
 010F                   .dbline 274
 010F           ;       else
 010F           ;       {       
 010F                   .dbline 275
 010F           ;               Heater_Output=Heater_PID_Output_Bias+Heater_Pout+Heater_Iout;                   
 010F 5116              mov A,[_Heater_Pout+1]
 0111 0180              add A,-128
 0113 5300              mov [__r1],A
 0115 5115              mov A,[_Heater_Pout]
 0117 0900              adc A,0
 0119 5300              mov [__r0],A
 011B 5100              mov A,[__r1]
 011D 0214              add A,[_Heater_Iout+1]
 011F 5318              mov [_Heater_Output+1],A
 0121 5100              mov A,[__r0]
 0123 0A13              adc A,[_Heater_Iout]
 0125 5317              mov [_Heater_Output],A
 0127                   .dbline 276
 0127           ;       }
 0127           L11:
 0127                   .dbline 278
 0127           ;       //Heater_Output=Heater_PID_Output_Bias+Heater_Pout+Heater_Iout; 
 0127           ;       if (Heater_Output<0)
 0127 5118              mov A,[_Heater_Output+1]
 0129 1100              sub A,0
 012B 5117              mov A,[_Heater_Output]
 012D 3180              xor A,-128
 012F 1980              sbb A,(0 ^ 0x80)
 0131 D007              jnc L12
 0133           X13:
 0133                   .dbline 280
 0133           ;       {
 0133           ;               Heater_Output=0;
 0133                   .dbline 280
 0133 551800            mov [_Heater_Output+1],0
 0136 551700            mov [_Heater_Output],0
 0139                   .dbline 281
 0139           ;       }
 0139           L12:
 0139                   .dbline 282
 0139           ;       if (Heater_Output>255)
 0139 50FF              mov A,-1
 013B 1218              sub A,[_Heater_Output+1]
 013D 5117              mov A,[_Heater_Output]
 013F 3180              xor A,-128
 0141 5300              mov [__rX],A
 0143 5080              mov A,(0 ^ 0x80)
 0145 1A00              sbb A,[__rX]
 0147 D007              jnc L14
 0149           X14:
 0149                   .dbline 284
 0149           ;       {
 0149           ;               Heater_Output=255;
 0149                   .dbline 284
 0149 5518FF            mov [_Heater_Output+1],-1
 014C 551700            mov [_Heater_Output],0
 014F                   .dbline 285
 014F           ;       }
 014F           L14:
 014F                   .dbline 288
 014F           ; 
 014F           ; 
 014F           ;       PWM8_Heater_WritePulseWidth(Heater_Output);
 014F 5F0018            mov [__r0],[_Heater_Output+1]
 0152 10                push X
 0153 5100              mov A,[__r0]
 0155 7C0000            xcall _PWM8_Heater_WritePulseWidth
 0158 20                pop X
 0159                   .dbline -2
 0159           L1:
 0159                   .dbline 0 ; func end
 0159 7F                ret
 015A                   .dbend
 015A                   .dbfunc e Ia_PID _Ia_PID fV
 015A           _Ia_PID::
 015A                   .dbline -1
 015A                   .dbline 300
 015A           ;       //PWM8_Heater_WritePulseWidth(200);
 015A           ; }
 015A           ; 
 015A           ; INT Ri_Mid_Error;
 015A           ; INT Ia_Output;
 015A           ; INT Ia_Pout;
 015A           ; INT Ia_Iout;
 015A           ; //PID Controller, Input is Ri_Mid (The average voltage on the Vs Port of the sensor) output is DAC9_Ia, DAC9_Ia sink/sources current to the Sensor pump cell such that Ri_Mid is is the same voltage as Vref
 015A           ; //Only a PI controller is used as adding the D term does not effect performance 
 015A           ; //Everything is inflated by a factor of 4 so that floating point is avioded
 015A           ; void Ia_PID(void)
 015A           ; {
 015A                   .dbline 303
 015A           ; 
 015A           ; 
 015A           ;       Ri_Mid_Error=Ri_Mid_Target-Ri_Mid;
 015A 501E              mov A,30
 015C 121E              sub A,[_Ri_Mid+1]
 015E 5312              mov [_Ri_Mid_Error+1],A
 0160 5001              mov A,1
 0162 1A1D              sbb A,[_Ri_Mid]
 0164 5311              mov [_Ri_Mid_Error],A
 0166                   .dbline 305
 0166           ;       //Put limits on Error so PID does not go Fubar, and also so that the worst case multiplication does not overflow
 0166           ;       if (Ri_Mid_Error>(255*16/Ia_PID_Kp))
 0166 50A3              mov A,-93
 0168 1212              sub A,[_Ri_Mid_Error+1]
 016A 5111              mov A,[_Ri_Mid_Error]
 016C 3180              xor A,-128
 016E 5300              mov [__rX],A
 0170 5080              mov A,(0 ^ 0x80)
 0172 1A00              sbb A,[__rX]
 0174 D007              jnc L17
 0176           X15:
 0176                   .dbline 307
 0176           ;       {
 0176           ;               Ri_Mid_Error=(255*16/Ia_PID_Kp); // 163
 0176                   .dbline 307
 0176 5512A3            mov [_Ri_Mid_Error+1],-93
 0179 551100            mov [_Ri_Mid_Error],0
 017C                   .dbline 308
 017C           ;       }
 017C           L17:
 017C                   .dbline 309
 017C           ;       if (Ri_Mid_Error<(-255*16/Ia_PID_Kp))
 017C 5112              mov A,[_Ri_Mid_Error+1]
 017E 115D              sub A,93
 0180 5111              mov A,[_Ri_Mid_Error]
 0182 3180              xor A,-128
 0184 197F              sbb A,(-1 ^ 0x80)
 0186 D007              jnc L19
 0188           X16:
 0188                   .dbline 311
 0188           ;       {
 0188           ;               Ri_Mid_Error=(-255*16/Ia_PID_Kp); // -163
 0188                   .dbline 311
 0188 55125D            mov [_Ri_Mid_Error+1],93
 018B 5511FF            mov [_Ri_Mid_Error],-1
 018E                   .dbline 312
 018E           ;       }
 018E           L19:
 018E                   .dbline 313
 018E           ;       Ia_Pout=(Ia_PID_Kp*Ri_Mid_Error)/16;
 018E 5F0012            mov [__r1],[_Ri_Mid_Error+1]
 0191 5F0011            mov [__r0],[_Ri_Mid_Error]
 0194 550019            mov [__r3],25
 0197 550000            mov [__r2],0
 019A 550000            mov [__rX],0
 019D 550000            mov [__rY],0
 01A0           X17:
 01A0 3C0000            cmp [__r2],0
 01A3 B006              jnz X20
 01A5 3C0000            cmp [__r3],0
 01A8 A017              jz X19
 01AA           X20:
 01AA 70FB              and F,-5
 01AC 6E00              rrc [__r2]
 01AE 6E00              rrc [__r3]
 01B0 D009              jnc X18
 01B2 5100              mov A,[__r1]
 01B4 0400              add [__rX],A
 01B6 5100              mov A,[__r0]
 01B8 0C00              adc [__rY],A
 01BA           X18:
 01BA 6500              asl [__r1]
 01BC 6B00              rlc [__r0]
 01BE 8FE1              jmp X17
 01C0           X19:
 01C0 5F0000            mov [__r1],[__rX]
 01C3 5F0000            mov [__r0],[__rY]
 01C6 5000              mov A,0
 01C8 08                push A
 01C9 5010              mov A,16
 01CB 08                push A
 01CC 5100              mov A,[__r0]
 01CE 08                push A
 01CF 5100              mov A,[__r1]
 01D1 08                push A
 01D2 7C0000            xcall __divmod_16X16_16
 01D5 18                pop A
 01D6 530E              mov [_Ia_Pout+1],A
 01D8 18                pop A
 01D9 530D              mov [_Ia_Pout],A
 01DB 38FE              add SP,-2
 01DD                   .dbline 314
 01DD           ;       Ri_Mid_Error_Sum=Ri_Mid_Error_Sum+Ri_Mid_Error;
 01DD 5112              mov A,[_Ri_Mid_Error+1]
 01DF 0401              add [_Ri_Mid_Error_Sum+1],A
 01E1 5111              mov A,[_Ri_Mid_Error]
 01E3 0C00              adc [_Ri_Mid_Error_Sum],A
 01E5                   .dbline 316
 01E5           ;       //Put limits on Error so PID does not go Fubar, and also so that the worst case multiplication does not overflow
 01E5           ;       if (Ri_Mid_Error_Sum>(255*16/Ia_PID_Ki))
 01E5 50FC              mov A,-4
 01E7 1201              sub A,[_Ri_Mid_Error_Sum+1]
 01E9 5100              mov A,[_Ri_Mid_Error_Sum]
 01EB 3180              xor A,-128
 01ED 5300              mov [__rX],A
 01EF 5083              mov A,(3 ^ 0x80)
 01F1 1A00              sbb A,[__rX]
 01F3 D007              jnc L21
 01F5           X21:
 01F5                   .dbline 318
 01F5           ;       {
 01F5           ;               Ri_Mid_Error_Sum=(255*16/Ia_PID_Ki); // 1020
 01F5                   .dbline 318
 01F5 5501FC            mov [_Ri_Mid_Error_Sum+1],-4
 01F8 550003            mov [_Ri_Mid_Error_Sum],3
 01FB                   .dbline 319
 01FB           ;       }
 01FB           L21:
 01FB                   .dbline 320
 01FB           ;       if (Ri_Mid_Error_Sum<(-255*16/Ia_PID_Ki))
 01FB 5101              mov A,[_Ri_Mid_Error_Sum+1]
 01FD 1104              sub A,4
 01FF 5100              mov A,[_Ri_Mid_Error_Sum]
 0201 3180              xor A,-128
 0203 197C              sbb A,(-4 ^ 0x80)
 0205 D007              jnc L23
 0207           X22:
 0207                   .dbline 322
 0207           ;       {
 0207           ;               Ri_Mid_Error_Sum=(-255*16/Ia_PID_Ki); // -1020
 0207                   .dbline 322
 0207 550104            mov [_Ri_Mid_Error_Sum+1],4
 020A 5500FC            mov [_Ri_Mid_Error_Sum],-4
 020D                   .dbline 323
 020D           ;       }
 020D           L23:
 020D                   .dbline 324
 020D           ;       Ia_Iout=(Ia_PID_Ki*Ri_Mid_Error_Sum)/16;
 020D 5F0001            mov [__r1],[_Ri_Mid_Error_Sum+1]
 0210 5F0000            mov [__r0],[_Ri_Mid_Error_Sum]
 0213 6500              asl [__r1]
 0215 6B00              rlc [__r0]
 0217 6500              asl [__r1]
 0219 6B00              rlc [__r0]
 021B 5000              mov A,0
 021D 08                push A
 021E 5010              mov A,16
 0220 08                push A
 0221 5100              mov A,[__r0]
 0223 08                push A
 0224 5100              mov A,[__r1]
 0226 08                push A
 0227 7C0000            xcall __divmod_16X16_16
 022A 18                pop A
 022B 530C              mov [_Ia_Iout+1],A
 022D 18                pop A
 022E 530B              mov [_Ia_Iout],A
 0230 38FE              add SP,-2
 0232                   .dbline 325
 0232           ;       Ia_Output=Ia_Output_Bias+Ia_Pout+Ia_Iout;
 0232 510E              mov A,[_Ia_Pout+1]
 0234 0100              add A,0
 0236 5300              mov [__r1],A
 0238 510D              mov A,[_Ia_Pout]
 023A 0901              adc A,1
 023C 5300              mov [__r0],A
 023E 5100              mov A,[__r1]
 0240 020C              add A,[_Ia_Iout+1]
 0242 5310              mov [_Ia_Output+1],A
 0244 5100              mov A,[__r0]
 0246 0A0B              adc A,[_Ia_Iout]
 0248 530F              mov [_Ia_Output],A
 024A                   .dbline 327
 024A           ;       //9 Bit Dac so only 0-511 is allowed, for some reason i put the limit at 510, I foget exactly why.
 024A           ;       if (Ia_Output<0)
 024A 5110              mov A,[_Ia_Output+1]
 024C 1100              sub A,0
 024E 510F              mov A,[_Ia_Output]
 0250 3180              xor A,-128
 0252 1980              sbb A,(0 ^ 0x80)
 0254 D007              jnc L25
 0256           X23:
 0256                   .dbline 329
 0256           ;       {
 0256           ;               Ia_Output=0;
 0256                   .dbline 329
 0256 551000            mov [_Ia_Output+1],0
 0259 550F00            mov [_Ia_Output],0
 025C                   .dbline 330
 025C           ;       }
 025C           L25:
 025C                   .dbline 331
 025C           ;       if (Ia_Output>510)
 025C 50FE              mov A,-2
 025E 1210              sub A,[_Ia_Output+1]
 0260 510F              mov A,[_Ia_Output]
 0262 3180              xor A,-128
 0264 5300              mov [__rX],A
 0266 5081              mov A,(1 ^ 0x80)
 0268 1A00              sbb A,[__rX]
 026A D007              jnc L27
 026C           X24:
 026C                   .dbline 333
 026C           ;       {
 026C           ;               Ia_Output=510;
 026C                   .dbline 333
 026C 5510FE            mov [_Ia_Output+1],-2
 026F 550F01            mov [_Ia_Output],1
 0272                   .dbline 334
 0272           ;       }
 0272           L27:
 0272                   .dbline 335
 0272           ;       DAC9_Ia_WriteStall (Ia_Output);
 0272 10                push X
 0273 580F              mov X,[_Ia_Output]
 0275 5110              mov A,[_Ia_Output+1]
 0277 7C0000            xcall _DAC9_Ia_WriteStall
 027A 20                pop X
 027B                   .dbline -2
 027B           L16:
 027B                   .dbline 0 ; func end
 027B 7F                ret
 027C                   .dbend
 027C                   .dbfunc e IIR_Int _IIR_Int fI
 027C           ;              A -> X-8
 027C           ;           Vout -> X-7
 027C           ;            Vin -> X-5
 027C           _IIR_Int::
 027C                   .dbline -1
 027C 10                push X
 027D 4F                mov X,SP
 027E                   .dbline 339
 027E           ;       //DAC9_Ia_WriteStall (256);
 027E           ; }
 027E           ; INT IIR_Int(INT Vin, INT Vout, BYTE A)
 027E           ; {
 027E                   .dbline 340
 027E           ;       return (Vout + (Vin - Vout)/A);
 027E 52FC              mov A,[X-4]
 0280 13FA              sub A,[X-6]
 0282 5300              mov [__r1],A
 0284 52FB              mov A,[X-5]
 0286 1BF9              sbb A,[X-7]
 0288 5300              mov [__r0],A
 028A 52F8              mov A,[X-8]
 028C 5300              mov [__r3],A
 028E 5000              mov A,0
 0290 08                push A
 0291 5100              mov A,[__r3]
 0293 08                push A
 0294 5100              mov A,[__r0]
 0296 08                push A
 0297 5100              mov A,[__r1]
 0299 08                push A
 029A 7C0000            xcall __divmod_16X16_16
 029D 18                pop A
 029E 5300              mov [__r1],A
 02A0 18                pop A
 02A1 5300              mov [__r0],A
 02A3 38FE              add SP,-2
 02A5 52FA              mov A,[X-6]
 02A7 0200              add A,[__r1]
 02A9 5300              mov [__r1],A
 02AB 52F9              mov A,[X-7]
 02AD 0A00              adc A,[__r0]
 02AF 5300              mov [__r0],A
 02B1                   .dbline -2
 02B1           L29:
 02B1 20                pop X
 02B2                   .dbline 0 ; func end
 02B2 7F                ret
 02B3                   .dbsym l A -8 c
 02B3                   .dbsym l Vout -7 I
 02B3                   .dbsym l Vin -5 I
 02B3                   .dbend
                        .area data(ram, con, rel)
 0005                   .dbfile I:\PSOCDO~1\WBOOS_~2\DSTAGE~1\DSTAGE~1\main.c
 0005           _Ia_PID_Counter::
 0005                   .blkb 1
                        .area idata(rom,lit)
 0005 00                .byte 0
                        .area data(ram, con, rel)
 0006                   .dbfile I:\PSOCDO~1\WBOOS_~2\DSTAGE~1\DSTAGE~1\main.c
 0006                   .dbsym e Ia_PID_Counter _Ia_PID_Counter c
 0006           _Vout_Lookup_Counter::
 0006                   .blkb 1
                        .area idata(rom,lit)
 0006 00                .byte 0
                        .area data(ram, con, rel)
 0007                   .dbfile I:\PSOCDO~1\WBOOS_~2\DSTAGE~1\DSTAGE~1\main.c
 0007                   .dbsym e Vout_Lookup_Counter _Vout_Lookup_Counter c
 0007           _Heater_PID_Counter::
 0007                   .blkb 1
                        .area idata(rom,lit)
 0007 00                .byte 0
                        .area data(ram, con, rel)
 0008                   .dbfile I:\PSOCDO~1\WBOOS_~2\DSTAGE~1\DSTAGE~1\main.c
 0008                   .dbsym e Heater_PID_Counter _Heater_PID_Counter c
 0008           _LCD_Counter::
 0008                   .blkb 1
                        .area idata(rom,lit)
 0008 00                .byte 0
                        .area data(ram, con, rel)
 0009                   .dbfile I:\PSOCDO~1\WBOOS_~2\DSTAGE~1\DSTAGE~1\main.c
 0009                   .dbsym e LCD_Counter _LCD_Counter c
 0009           _Heatup_Counter::
 0009                   .blkb 1
                        .area idata(rom,lit)
 0009 00                .byte 0
                        .area data(ram, con, rel)
 000A                   .dbfile I:\PSOCDO~1\WBOOS_~2\DSTAGE~1\DSTAGE~1\main.c
 000A                   .dbsym e Heatup_Counter _Heatup_Counter c
                        .area lit(rom, con, rel, lit)
 01E4           L31:
 01E4 0006              .byte 0,6
 01E6 4040              .byte 64,64
                        .area text(rom, con, rel)
 02B3                   .dbfile I:\PSOCDO~1\WBOOS_~2\DSTAGE~1\DSTAGE~1\main.c
 02B3                   .dbfunc e main _main fV
 02B3           ;      temp_int2 -> X+11
 02B3           ;     temp_ulong -> X+7
 02B3           ;         digits -> X+3
 02B3           ;      temp_byte -> X+2
 02B3           ;       temp_int -> X+0
 02B3           _main::
 02B3                   .dbline -1
 02B3 10                push X
 02B4 4F                mov X,SP
 02B5 380D              add SP,13
 02B7                   .dbline 356
 02B7           ; }
 02B7           ; 
 02B7           ; 
 02B7           ; BYTE Ia_PID_Counter=0;
 02B7           ; BYTE Vout_Lookup_Counter=0;
 02B7           ; BYTE Heater_PID_Counter=0;
 02B7           ; BYTE LCD_Counter=0;
 02B7           ; BYTE Heatup_Counter=0;
 02B7           ; INT Ri_Min,Ri_Max;
 02B7           ; INT ip,ip_Justified;
 02B7           ; BYTE Lambda_x100;
 02B7           ; INT LSU_Temperature_C;
 02B7           ; //char Str1[] = "Lambda=x.xx";
 02B7           ; //char Str2[] = "Temperature=xxxC"; 
 02B7           ; void main(void)
 02B7           ; {
 02B7                   .dbline 363
 02B7           ;       unsigned long temp_ulong;
 02B7           ;       INT temp_int,temp_int2;
 02B7           ;       BYTE temp_byte;
 02B7           ;       
 02B7           ;       #if defined LED_AFR || defined LED_Lambda
 02B7           ;               // empty, 1, -, -
 02B7           ;               BYTE digits[4] = {0b00000000, 0b00000110, 0b01000000, 0b01000000};
 02B7 5500E4            mov [__r1],<L31
 02BA 5500E4            mov [__r0],>L31
 02BD 5A00              mov [__r3],X
 02BF 060003            add [__r3],3
 02C2 10                push X
 02C3 550000            mov [__rX],0
 02C6 5100              mov A,[__r0]
 02C8 5800              mov X,[__r1]
 02CA           X26:
 02CA 08                push A
 02CB 28                romx
 02CC 3F00              mvi [__r3],A
 02CE 18                pop A
 02CF 75                inc X
 02D0 0900              adc A,0
 02D2 7600              inc [__rX]
 02D4 3C0004            cmp [__rX],4
 02D7 BFF2              jnz X26
 02D9                   .dbline 366
 02D9           ;       #endif
 02D9           ;       
 02D9           ;       AMUX4_0_InputSelect(AMUX4_0_PORT0_1);        
 02D9 5000              mov A,0
 02DB 7C0000            xcall _AMUX4_0_InputSelect
 02DE                   .dbline 367
 02DE           ;       AMUX4_1_InputSelect(AMUX4_1_PORT0_0);
 02DE 5000              mov A,0
 02E0 7C0000            xcall _AMUX4_1_InputSelect
 02E3                   .dbline 368
 02E3           ;       INSAMP_Start(INSAMP_LOWPOWER); 
 02E3 5001              mov A,1
 02E5 7C0000            xcall _INSAMP_Start
 02E8                   .dbline 369
 02E8           ;     ADCINC_Start(ADCINC_HIGHPOWER);      
 02E8 5003              mov A,3
 02EA 7C0000            xcall _ADCINC_Start
 02ED                   .dbline 370
 02ED           ;       DAC9_Ia_Start(DAC9_Ia_HIGHPOWER);
 02ED 5003              mov A,3
 02EF 7C0000            xcall _DAC9_Ia_Start
 02F2                   .dbline 371
 02F2           ;       DAC6_VGND_Start(DAC6_VGND_MEDPOWER);
 02F2 5002              mov A,2
 02F4 7C0000            xcall _DAC6_VGND_Start
 02F7                   .dbline 372
 02F7           ;       DAC6_VGND_WriteStall (31);
 02F7 501F              mov A,31
 02F9 7C0000            xcall _DAC6_VGND_WriteStall
 02FC                   .dbline 373
 02FC           ;     PWM8_Vout_DisableInt();  
 02FC 7C0000            xcall _PWM8_Vout_DisableInt
 02FF                   .dbline 374
 02FF           ;     PWM8_Vout_Start();     
 02FF 7C0000            xcall _PWM8_Vout_Start
 0302                   .dbline 375
 0302           ;     PWM8_Heater_DisableInt();  
 0302 7C0000            xcall _PWM8_Heater_DisableInt
 0305                   .dbline 376
 0305           ;     PWM8_Heater_Start();
 0305 7C0000            xcall _PWM8_Heater_Start
 0308                   .dbline 377
 0308           ;       PWM8_NB_Out_DisableInt();  
 0308 7C0000            xcall _PWM8_NB_Out_DisableInt
 030B                   .dbline 378
 030B           ;     PWM8_NB_Out_Start(); 
 030B 7C0000            xcall _PWM8_NB_Out_Start
 030E                   .dbline 379
 030E           ;       ADCINC_GetSamples(0);
 030E 5000              mov A,0
 0310 7C0000            xcall _ADCINC_GetSamples
 0313                   .dbline 380
 0313           ;       SleepTimer_Start();  
 0313 7C0000            xcall _SleepTimer_Start
 0316                   .dbline 381
 0316           ;       SleepTimer_SetInterval(SleepTimer_512_HZ);  
 0316 5000              mov A,0
 0318 7C0000            xcall _SleepTimer_SetInterval
 031B                   .dbline 382
 031B           ;       SleepTimer_EnableInt();   
 031B 7C0000            xcall _SleepTimer_EnableInt
 031E 20                pop X
 031F                   .dbline 383
 031F           ;       M8C_EnableGInt ;  
 031F 7101                      or  F, 01h
 0321           
 0321                   .dbline 425
 0321           ;       
 0321           ;       // initialize LCD only when needed (DStage WBOOS can be used with LED or without any display)
 0321           ;       #if defined LCD_AFR_digits || defined LCD_Lambda_digits || defined LCD_Temperature_digits || defined DStage_logo || defined LCD_Lambda_Graph || defined LCD_Temperature_Graph
 0321           ;               LCD_Start();                  // Initialize LCD
 0321           ;               LCD_InitBG(LCD_SOLID_BG);
 0321           ;       #endif
 0321           ; 
 0321           ;       #ifdef LCD_AFR_digits
 0321           ;               LCD_Position(0,0);
 0321           ;               LCD_PrCString("AFR: 1\0");
 0321           ;       #endif
 0321           ;       
 0321           ;       #ifdef LCD_Lambda_digits
 0321           ;               LCD_Position(0,0);
 0321           ;               LCD_PrCString("LAM: 0\0");
 0321           ;       #endif
 0321           ;       
 0321           ;       #ifdef LCD_Temperature_digits
 0321           ;               #ifdef LCD_Lambda_Graph
 0321           ;                       LCD_Position(0,10);
 0321           ;                       LCD_PrCString("T:\0");
 0321           ;                       LCD_Position(0,15);
 0321           ;                       LCD_WriteData(0xDF); // degre
 0321           ;               #else
 0321           ;                       LCD_Position(1,0);
 0321           ;                       LCD_PrCString("TMP:\0");
 0321           ;                       LCD_Position(1,8);
 0321           ;                       LCD_WriteData(0xDF); // degre
 0321           ;               #endif
 0321           ;       #endif
 0321           ;       
 0321           ;       #ifdef DStage_logo
 0321           ;               #ifndef LCD_Lambda_Graph
 0321           ;                       LCD_Position(0,10);
 0321           ;                       LCD_PrCString("DStage\0");
 0321           ;                       LCD_Position(1,10);
 0321           ;                       LCD_PrCString("Garage\0");
 0321           ;               #endif
 0321           ;       #endif
 0321           ;       
 0321           ;       #if defined LED_AFR || defined LED_Lambda
 0321           ;               TM1637_init();
 0321 93AE              xcall _TM1637_init
 0323                   .dbline 426
 0323           ;               TM1637_setSegments(digits, 4, 0);
 0323 5000              mov A,0
 0325 08                push A
 0326 5004              mov A,4
 0328 08                push A
 0329 5A00              mov [__r1],X
 032B 060003            add [__r1],3
 032E 5100              mov A,[__r0]
 0330 08                push A
 0331 5100              mov A,[__r1]
 0333 08                push A
 0334 93CC              xcall _TM1637_setSegments
 0336 38FC              add SP,-4
 0338                   .dbline 430
 0338           ;               //TM1637_showNumberDec(123, 0, 3, 1);
 0338           ;       #endif
 0338           ; 
 0338           ;       for(;;)
 0338           L32:
 0338                   .dbline 431
 0338           ;     {
 0338                   .dbline 432
 0338           ;               temp_ulong++;
 0338 070A01            add [X+10],1
 033B 0F0900            adc [X+9],0
 033E 0F0800            adc [X+8],0
 0341 0F0700            adc [X+7],0
 0344                   .dbline 433
 0344           ;               if ((ADC_IF&1)==1)
 0344 5100              mov A,[_ADC_IF]
 0346 2101              and A,1
 0348 3901              cmp A,1
 034A B056              jnz L36
 034C                   .dbline 435
 034C           ;               {
 034C           ;                       ADC_IF=ADC_IF&254;
 034C                   .dbline 435
 034C 2600FE            and [_ADC_IF],-2
 034F                   .dbline 436
 034F           ;                       Ri_Min=IIR_Int(Ri_Min_x1*2,Ri_Min,Ri_Filter_Strength);
 034F 5004              mov A,4
 0351 08                push A
 0352 5109              mov A,[_Ri_Min]
 0354 08                push A
 0355 510A              mov A,[_Ri_Min+1]
 0357 08                push A
 0358 5F0000            mov [__r1],[_Ri_Min_x1]
 035B 550000            mov [__r0],0
 035E 6500              asl [__r1]
 0360 6B00              rlc [__r0]
 0362 5100              mov A,[__r0]
 0364 08                push A
 0365 5100              mov A,[__r1]
 0367 08                push A
 0368 9F12              xcall _IIR_Int
 036A 38FB              add SP,-5
 036C 5F0A00            mov [_Ri_Min+1],[__r1]
 036F 5F0900            mov [_Ri_Min],[__r0]
 0372                   .dbline 437
 0372           ;                       Ri_Delta=Ri_Max-Ri_Min;
 0372 5108              mov A,[_Ri_Max+1]
 0374 120A              sub A,[_Ri_Min+1]
 0376 531C              mov [_Ri_Delta+1],A
 0378 5107              mov A,[_Ri_Max]
 037A 1A09              sbb A,[_Ri_Min]
 037C 531B              mov [_Ri_Delta],A
 037E                   .dbline 438
 037E           ;                       Ri_Mid=(Ri_Max+Ri_Min)/2;
 037E 5108              mov A,[_Ri_Max+1]
 0380 020A              add A,[_Ri_Min+1]
 0382 5300              mov [__r1],A
 0384 5107              mov A,[_Ri_Max]
 0386 0A09              adc A,[_Ri_Min]
 0388 5300              mov [__r0],A
 038A 5000              mov A,0
 038C 08                push A
 038D 5002              mov A,2
 038F 08                push A
 0390 5100              mov A,[__r0]
 0392 08                push A
 0393 5100              mov A,[__r1]
 0395 08                push A
 0396 7C0000            xcall __divmod_16X16_16
 0399 18                pop A
 039A 531E              mov [_Ri_Mid+1],A
 039C 18                pop A
 039D 531D              mov [_Ri_Mid],A
 039F 38FE              add SP,-2
 03A1                   .dbline 439
 03A1           ;               }
 03A1           L36:
 03A1                   .dbline 440
 03A1           ;               if ((ADC_IF&2)==2)
 03A1 5100              mov A,[_ADC_IF]
 03A3 2102              and A,2
 03A5 3902              cmp A,2
 03A7 B056              jnz L38
 03A9                   .dbline 442
 03A9           ;               {
 03A9           ;                       ADC_IF=ADC_IF&253;
 03A9                   .dbline 442
 03A9 2600FD            and [_ADC_IF],-3
 03AC                   .dbline 443
 03AC           ;                       Ri_Max=IIR_Int(Ri_Max_x1*2,Ri_Max,Ri_Filter_Strength);
 03AC 5004              mov A,4
 03AE 08                push A
 03AF 5107              mov A,[_Ri_Max]
 03B1 08                push A
 03B2 5108              mov A,[_Ri_Max+1]
 03B4 08                push A
 03B5 5F0000            mov [__r1],[_Ri_Max_x1]
 03B8 550000            mov [__r0],0
 03BB 6500              asl [__r1]
 03BD 6B00              rlc [__r0]
 03BF 5100              mov A,[__r0]
 03C1 08                push A
 03C2 5100              mov A,[__r1]
 03C4 08                push A
 03C5 9EB5              xcall _IIR_Int
 03C7 38FB              add SP,-5
 03C9 5F0800            mov [_Ri_Max+1],[__r1]
 03CC 5F0700            mov [_Ri_Max],[__r0]
 03CF                   .dbline 444
 03CF           ;                       Ri_Delta=Ri_Max-Ri_Min;
 03CF 5108              mov A,[_Ri_Max+1]
 03D1 120A              sub A,[_Ri_Min+1]
 03D3 531C              mov [_Ri_Delta+1],A
 03D5 5107              mov A,[_Ri_Max]
 03D7 1A09              sbb A,[_Ri_Min]
 03D9 531B              mov [_Ri_Delta],A
 03DB                   .dbline 445
 03DB           ;                       Ri_Mid=(Ri_Max+Ri_Min)/2;
 03DB 5108              mov A,[_Ri_Max+1]
 03DD 020A              add A,[_Ri_Min+1]
 03DF 5300              mov [__r1],A
 03E1 5107              mov A,[_Ri_Max]
 03E3 0A09              adc A,[_Ri_Min]
 03E5 5300              mov [__r0],A
 03E7 5000              mov A,0
 03E9 08                push A
 03EA 5002              mov A,2
 03EC 08                push A
 03ED 5100              mov A,[__r0]
 03EF 08                push A
 03F0 5100              mov A,[__r1]
 03F2 08                push A
 03F3 7C0000            xcall __divmod_16X16_16
 03F6 18                pop A
 03F7 531E              mov [_Ri_Mid+1],A
 03F9 18                pop A
 03FA 531D              mov [_Ri_Mid],A
 03FC 38FE              add SP,-2
 03FE                   .dbline 446
 03FE           ;               }
 03FE           L38:
 03FE                   .dbline 447
 03FE           ;               if ((ADC_IF&4)==4)
 03FE 5100              mov A,[_ADC_IF]
 0400 2104              and A,4
 0402 3904              cmp A,4
 0404 B027              jnz L40
 0406                   .dbline 449
 0406           ;               {
 0406           ;                       ADC_IF=ADC_IF&251;
 0406                   .dbline 449
 0406 2600FB            and [_ADC_IF],-5
 0409                   .dbline 450
 0409           ;                       ip=IIR_Int(ip_x1*2,ip,ip_Filter_Strength);
 0409 5004              mov A,4
 040B 08                push A
 040C 5105              mov A,[_ip]
 040E 08                push A
 040F 5106              mov A,[_ip+1]
 0411 08                push A
 0412 5F0000            mov [__r1],[_ip_x1]
 0415 550000            mov [__r0],0
 0418 6500              asl [__r1]
 041A 6B00              rlc [__r0]
 041C 5100              mov A,[__r0]
 041E 08                push A
 041F 5100              mov A,[__r1]
 0421 08                push A
 0422 9E58              xcall _IIR_Int
 0424 38FB              add SP,-5
 0426 5F0600            mov [_ip+1],[__r1]
 0429 5F0500            mov [_ip],[__r0]
 042C                   .dbline 451
 042C           ;               }
 042C           L40:
 042C                   .dbline 452
 042C           ;               Ia_PID_Counter+=Sleep_Counter;
 042C 5100              mov A,[_Sleep_Counter]
 042E 0405              add [_Ia_PID_Counter],A
 0430                   .dbline 453
 0430           ;               Heater_PID_Counter+=Sleep_Counter;
 0430 5100              mov A,[_Sleep_Counter]
 0432 0407              add [_Heater_PID_Counter],A
 0434                   .dbline 454
 0434           ;               Heatup_Counter+=Sleep_Counter;
 0434 5100              mov A,[_Sleep_Counter]
 0436 0409              add [_Heatup_Counter],A
 0438                   .dbline 455
 0438           ;               Vout_Lookup_Counter+=Sleep_Counter;
 0438 5100              mov A,[_Sleep_Counter]
 043A 0406              add [_Vout_Lookup_Counter],A
 043C                   .dbline 456
 043C           ;               LCD_Counter+=Sleep_Counter;
 043C 5100              mov A,[_Sleep_Counter]
 043E 0408              add [_LCD_Counter],A
 0440                   .dbline 457
 0440           ;               Sleep_Counter=0;
 0440 550000            mov [_Sleep_Counter],0
 0443                   .dbline 458
 0443           ;               if (Ia_PID_Counter>Ia_PID_Counter_Set)
 0443 5001              mov A,1
 0445 3A05              cmp A,[_Ia_PID_Counter]
 0447 D006              jnc L42
 0449           X27:
 0449                   .dbline 460
 0449           ;               {
 0449           ;                       Ia_PID_Counter=0;
 0449                   .dbline 460
 0449 550500            mov [_Ia_PID_Counter],0
 044C                   .dbline 461
 044C           ;                       Ia_PID();
 044C 9D0C              xcall _Ia_PID
 044E                   .dbline 462
 044E           ;               }
 044E           L42:
 044E                   .dbline 463
 044E           ;               if (Heater_PID_Counter>Heater_PID_Counter_Set)
 044E 5019              mov A,25
 0450 3A07              cmp A,[_Heater_PID_Counter]
 0452 D006              jnc L44
 0454           X28:
 0454                   .dbline 465
 0454           ;               {
 0454           ;                       Heater_PID_Counter=0;
 0454                   .dbline 465
 0454 550700            mov [_Heater_PID_Counter],0
 0457                   .dbline 466
 0457           ;                       Heater_PID();
 0457 9BA7              xcall _Heater_PID
 0459                   .dbline 467
 0459           ;               }
 0459           L44:
 0459                   .dbline 468
 0459           ;               if (Vout_Lookup_Counter>Vout_Lookup_Counter_Set)
 0459 5019              mov A,25
 045B 3A06              cmp A,[_Vout_Lookup_Counter]
 045D D076              jnc L46
 045F           X29:
 045F                   .dbline 470
 045F           ;               {
 045F           ;                       Vout_Lookup_Counter=0;
 045F                   .dbline 470
 045F 550600            mov [_Vout_Lookup_Counter],0
 0462                   .dbline 471
 0462           ;                       temp_int=ip-ip_to_Vout_Lookup_Start;
 0462 5106              mov A,[_ip+1]
 0464 1187              sub A,-121
 0466 5401              mov [X+1],A
 0468 5105              mov A,[_ip]
 046A 1900              sbb A,0
 046C 5400              mov [X+0],A
 046E                   .dbline 472
 046E           ;                       if (temp_int<0)
 046E 5201              mov A,[X+1]
 0470 1100              sub A,0
 0472 5200              mov A,[X+0]
 0474 3180              xor A,-128
 0476 1980              sbb A,(0 ^ 0x80)
 0478 D007              jnc L48
 047A           X30:
 047A                   .dbline 474
 047A           ;                       {
 047A           ;                               temp_int=0;
 047A                   .dbline 474
 047A 560100            mov [X+1],0
 047D 560000            mov [X+0],0
 0480                   .dbline 475
 0480           ;                       }
 0480           L48:
 0480                   .dbline 476
 0480           ;                       if (temp_int>(ip_to_Vout_Lookup_Size-1))
 0480 509D              mov A,-99
 0482 1301              sub A,[X+1]
 0484 5200              mov A,[X+0]
 0486 3180              xor A,-128
 0488 5300              mov [__rX],A
 048A 5080              mov A,(0 ^ 0x80)
 048C 1A00              sbb A,[__rX]
 048E D007              jnc L50
 0490           X31:
 0490                   .dbline 478
 0490           ;                       {
 0490           ;                               temp_int=(ip_to_Vout_Lookup_Size-1);
 0490                   .dbline 478
 0490 56019D            mov [X+1],-99
 0493 560000            mov [X+0],0
 0496                   .dbline 479
 0496           ;                       }
 0496           L50:
 0496                   .dbline 480
 0496           ;                       PWM8_Vout_WritePulseWidth(ip_to_Vout_Lookup[temp_int]);
 0496 5201              mov A,[X+1]
 0498 0100              add A,<_ip_to_Vout_Lookup
 049A 5300              mov [__r1],A
 049C 5200              mov A,[X+0]
 049E 0900              adc A,>_ip_to_Vout_Lookup
 04A0 10                push X
 04A1 5800              mov X,[__r1]
 04A3 28                romx
 04A4 7C0000            xcall _PWM8_Vout_WritePulseWidth
 04A7 20                pop X
 04A8                   .dbline 483
 04A8           ;                       
 04A8           ;                       #ifdef NB_Out
 04A8           ;                               temp_byte=23;//0.45v
 04A8 560217            mov [X+2],23
 04AB                   .dbline 484
 04AB           ;                               if (ip<251) // 251 =0.9797787392968
 04AB 5106              mov A,[_ip+1]
 04AD 11FB              sub A,-5
 04AF 5105              mov A,[_ip]
 04B1 3180              xor A,-128
 04B3 1980              sbb A,(0 ^ 0x80)
 04B5 D004              jnc L52
 04B7           X32:
 04B7                   .dbline 486
 04B7           ;                               {
 04B7           ;                                       temp_byte=46; //0.9v
 04B7                   .dbline 486
 04B7 56022E            mov [X+2],46
 04BA                   .dbline 488
 04BA           ;                                       
 04BA           ;                               }
 04BA           L52:
 04BA                   .dbline 489
 04BA           ;                               if (ip>259) //259 = 1.02295956968912
 04BA 5003              mov A,3
 04BC 1206              sub A,[_ip+1]
 04BE 5105              mov A,[_ip]
 04C0 3180              xor A,-128
 04C2 5300              mov [__rX],A
 04C4 5081              mov A,(1 ^ 0x80)
 04C6 1A00              sbb A,[__rX]
 04C8 D004              jnc L54
 04CA           X33:
 04CA                   .dbline 491
 04CA           ;                               {
 04CA           ;                                       temp_byte=0; //0v
 04CA                   .dbline 491
 04CA 560200            mov [X+2],0
 04CD                   .dbline 492
 04CD           ;                               }
 04CD           L54:
 04CD                   .dbline 493
 04CD           ;                               PWM8_NB_Out_WritePulseWidth(temp_byte);
 04CD 10                push X
 04CE 5202              mov A,[X+2]
 04D0 7C0000            xcall _PWM8_NB_Out_WritePulseWidth
 04D3 20                pop X
 04D4                   .dbline 496
 04D4           ;                       #endif
 04D4           ;                       
 04D4           ;               }
 04D4           L46:
 04D4                   .dbline 497
 04D4           ;               if (LCD_Counter>LCD_Counter_Set)
 04D4 5032              mov A,50
 04D6 3A08              cmp A,[_LCD_Counter]
 04D8 D1B0              jnc L56
 04DA           X34:
 04DA                   .dbline 499
 04DA           ;               {
 04DA           ;                       LCD_Counter=0;
 04DA                   .dbline 499
 04DA 550800            mov [_LCD_Counter],0
 04DD                   .dbline 622
 04DD           ;                       
 04DD           ;                       #ifdef LCD_Lambda_Graph
 04DD           ;                               temp_int=ip-ip_to_Lambda_Lookup_Start;
 04DD           ;                               if (temp_int<0)
 04DD           ;                               {
 04DD           ;                                       temp_int=0;
 04DD           ;                               }
 04DD           ;                               if (temp_int>(ip_to_Lambda_Lookup_Size-1))
 04DD           ;                               {
 04DD           ;                                       temp_int=(ip_to_Lambda_Lookup_Size-1);
 04DD           ;                               }
 04DD           ;                               Lambda_x100=ip_to_Graph_Lookup[temp_int];
 04DD           ;                               
 04DD           ;                               // if both numeric AFR and Lambda bargraph is to be used put bargraph in second row
 04DD           ;                               #ifdef LCD_AFR_digits
 04DD           ;                                       LCD_DrawBG(1,0,16,Lambda_x100);
 04DD           ;                               #else
 04DD           ;                                       #ifdef LCD_Lambda_digits
 04DD           ;                                               LCD_DrawBG(1,0,16,Lambda_x100);
 04DD           ;                                       #else
 04DD           ;                                               LCD_DrawBG(0,0,16,Lambda_x100);
 04DD           ;                                       #endif
 04DD           ;                               #endif
 04DD           ;                       #endif
 04DD           ;                       
 04DD           ;                       #ifdef LCD_AFR_digits
 04DD           ;                               temp_int=ip-ip_to_AFR_Lookup_Start;
 04DD           ;                               if (temp_int<0)
 04DD           ;                               {
 04DD           ;                                       temp_int=0;
 04DD           ;                               }
 04DD           ;                               if (temp_int>(ip_to_AFR_Lookup_Size-1))
 04DD           ;                               {
 04DD           ;                                       temp_int=(ip_to_AFR_Lookup_Size-1);
 04DD           ;                               }
 04DD           ;                               temp_byte = temp_int;   // code size optimization
 04DD           ;                               
 04DD           ;                               // AFR integer part (temporarly first digit is always "1")
 04DD           ;                               LCD_Position(0,6);
 04DD           ;                               LCD_WriteData('0' + ((ip_to_AFR_Lookup[temp_byte] & 0xF0) >> 4));
 04DD           ;                               
 04DD           ;                               // AFR decimal point part
 04DD           ;                               LCD_WriteData('.');
 04DD           ;                               LCD_WriteData('0' + (ip_to_AFR_Lookup[temp_byte] & 0x0F));
 04DD           ;                       #endif
 04DD           ;                       
 04DD           ;                       #ifdef LCD_Lambda_digits
 04DD           ;                               temp_int=ip-ip_to_LambdaD_Lookup_Start; 
 04DD           ;                               if (temp_int<0)
 04DD           ;                               {
 04DD           ;                                       temp_int=0;
 04DD           ;                               }
 04DD           ;                               if (temp_int>(ip_to_LambdaD_Lookup_Size-1))
 04DD           ;                               {
 04DD           ;                                       temp_int=(ip_to_LambdaD_Lookup_Size-1);
 04DD           ;                               }
 04DD           ;                               temp_byte = temp_int;   // code size optimization
 04DD           ;                               
 04DD           ;                               // Lambda int part      
 04DD           ;                               LCD_Position(0,5);
 04DD           ;                               if (temp_byte < 120)    // 120th value is equal to lambda 1.00
 04DD           ;                                       Lambda_x100 = '0';
 04DD           ;                               else
 04DD           ;                                       Lambda_x100 = '1';
 04DD           ;                               LCD_WriteData(Lambda_x100);
 04DD           ;                               
 04DD           ;                               // Lambda 0.x part
 04DD           ;                               LCD_WriteData('.');
 04DD           ;                               LCD_WriteData('0' + ((ip_to_Lambda_Lookup[temp_byte] & 0xF0) >> 4));
 04DD           ;                               
 04DD           ;                               // Lambda 0.0x part
 04DD           ;                               LCD_WriteData('0' + (ip_to_Lambda_Lookup[temp_byte] & 0x0F));
 04DD           ;                       #endif
 04DD           ;                       
 04DD           ;                       #ifdef LCD_Temperature_Graph
 04DD           ;                               temp_int=Ri_Delta-Ri_Delta_to_Temperature_C_Start;
 04DD           ;                               if (temp_int<0)
 04DD           ;                               {
 04DD           ;                                       temp_int=0;
 04DD           ;                               }
 04DD           ;                               if (temp_int>(Ri_Delta_to_Temperature_C_Size-1))
 04DD           ;                               {
 04DD           ;                                       temp_int=(Ri_Delta_to_Temperature_C_Size-1);
 04DD           ;                               }
 04DD           ;                               LSU_Temperature_C=Ri_Delta_to_Graph[temp_int];
 04DD           ;                               LCD_DrawBG(1,0,16,LSU_Temperature_C);
 04DD           ;                       #endif
 04DD           ;                       
 04DD           ;                       #ifdef LCD_Temperature_digits
 04DD           ;                               temp_int=Ri_Delta-Ri_Delta_to_Temperature_C_dig_Start;
 04DD           ;                               if (temp_int<0)
 04DD           ;                               {
 04DD           ;                                       temp_int=0;
 04DD           ;                               }
 04DD           ;                               if (temp_int>(Ri_Delta_to_Temperature_C_dig_Size-1))
 04DD           ;                               {
 04DD           ;                                       temp_int=(Ri_Delta_to_Temperature_C_dig_Size-1);
 04DD           ;                               }
 04DD           ;                               temp_byte = temp_int;   // code size optimization
 04DD           ;       
 04DD           ;                               // Temperature hundreds part (7 or 8)   
 04DD           ;                               #ifdef LCD_Lambda_Graph
 04DD           ;                                       LCD_Position(0,12);
 04DD           ;                               #else
 04DD           ;                                       LCD_Position(1,5);
 04DD           ;                               #endif
 04DD           ; 
 04DD           ;                               if (temp_byte < 15)
 04DD           ;                                       Lambda_x100 = '8';
 04DD           ;                               else
 04DD           ;                                       Lambda_x100 = '7';
 04DD           ;                               
 04DD           ;                               LCD_WriteData(Lambda_x100);
 04DD           ;                                               
 04DD           ;                               // Temperature tens part
 04DD           ;                               LCD_WriteData('0' + ((Ri_Delta_to_dig[temp_int] & 0xF0) >> 4));
 04DD           ;                               
 04DD           ;                               // Temperature ones part
 04DD           ;                               LCD_WriteData('0' + (Ri_Delta_to_dig[temp_int] & 0x0F));
 04DD           ;                       #endif
 04DD           ;                       
 04DD           ;                       #ifdef LED_AFR          
 04DD           ;                               temp_int=ip-ip_to_AFR_Lookup_Start;
 04DD 5106              mov A,[_ip+1]
 04DF 1187              sub A,-121
 04E1 5401              mov [X+1],A
 04E3 5105              mov A,[_ip]
 04E5 1900              sbb A,0
 04E7 5400              mov [X+0],A
 04E9                   .dbline 623
 04E9           ;                               if (temp_int<0)
 04E9 5201              mov A,[X+1]
 04EB 1100              sub A,0
 04ED 5200              mov A,[X+0]
 04EF 3180              xor A,-128
 04F1 1980              sbb A,(0 ^ 0x80)
 04F3 D007              jnc L58
 04F5           X35:
 04F5                   .dbline 625
 04F5           ;                               {
 04F5           ;                                       temp_int=0;
 04F5                   .dbline 625
 04F5 560100            mov [X+1],0
 04F8 560000            mov [X+0],0
 04FB                   .dbline 626
 04FB           ;                               }
 04FB           L58:
 04FB                   .dbline 627
 04FB           ;                               if (temp_int>(ip_to_AFR_Lookup_Size-1))
 04FB 509D              mov A,-99
 04FD 1301              sub A,[X+1]
 04FF 5200              mov A,[X+0]
 0501 3180              xor A,-128
 0503 5300              mov [__rX],A
 0505 5080              mov A,(0 ^ 0x80)
 0507 1A00              sbb A,[__rX]
 0509 D007              jnc L60
 050B           X36:
 050B                   .dbline 629
 050B           ;                               {
 050B           ;                                       temp_int=(ip_to_AFR_Lookup_Size-1);
 050B                   .dbline 629
 050B 56019D            mov [X+1],-99
 050E 560000            mov [X+0],0
 0511                   .dbline 630
 0511           ;                               }
 0511           L60:
 0511                   .dbline 631
 0511           ;                               temp_byte = temp_int;   // code size optimization
 0511 5201              mov A,[X+1]
 0513 5402              mov [X+2],A
 0515                   .dbline 642
 0515           ;                               
 0515           ;                               /*// AFR integer part (temporarly first digit is always "1"), add dot
 0515           ;                               digits[0] = digitToSegment[(ip_to_AFR_Lookup[temp_byte] & 0xF0) >> 4] | 0x80;
 0515           ;                               
 0515           ;                               // AFR decimal part
 0515           ;                               digits[1] = digitToSegment[ip_to_AFR_Lookup[temp_byte] & 0x0F];
 0515           ;                               
 0515           ;                               TM1637_setSegments(digits, 2, 2);*/
 0515           ;                               
 0515           ;                               #ifdef LED_Lambda
 0515           ;                                       if ((SWPORT & SWPIN) == 0)
 0515 5D04              mov A,REG[0x4]
 0517 5300              mov [__r0],A
 0519 470080            tst [__r0],-128
 051C B08D              jnz L62
 051E                   .dbline 645
 051E           ;                                       {
 051E           ;                                               // AFR integer part (temporarly first digit is always "1"), add dot
 051E           ;                                               digits[1] = digitToSegment[(ip_to_AFR_Lookup[temp_byte] & 0xF0) >> 4] | 0x80;
 051E                   .dbline 645
 051E 5202              mov A,[X+2]
 0520 5300              mov [__r1],A
 0522 550000            mov [__r0],0
 0525 06009E            add [__r1],<_ip_to_AFR_Lookup
 0528 0E009E            adc [__r0],>_ip_to_AFR_Lookup
 052B 5100              mov A,[__r0]
 052D 10                push X
 052E 5800              mov X,[__r1]
 0530 28                romx
 0531 20                pop X
 0532 5300              mov [__r1],A
 0534 550000            mov [__r0],0
 0537 2600F0            and [__r1],-16
 053A 260000            and [__r0],0
 053D 6800              asr [__r0]
 053F 6E00              rrc [__r1]
 0541 6800              asr [__r0]
 0543 6E00              rrc [__r1]
 0545 6800              asr [__r0]
 0547 6E00              rrc [__r1]
 0549 6800              asr [__r0]
 054B 6E00              rrc [__r1]
 054D 0600DA            add [__r1],<_digitToSegment
 0550 0E00DA            adc [__r0],>_digitToSegment
 0553 5100              mov A,[__r0]
 0555 10                push X
 0556 5800              mov X,[__r1]
 0558 28                romx
 0559 20                pop X
 055A 2980              or A,-128
 055C 5404              mov [X+4],A
 055E                   .dbline 648
 055E           ;                                               
 055E           ;                                               // AFR decimal part
 055E           ;                                               digits[2] = digitToSegment[ip_to_AFR_Lookup[temp_byte] & 0x0F];
 055E 5202              mov A,[X+2]
 0560 5300              mov [__r1],A
 0562 550000            mov [__r0],0
 0565 06009E            add [__r1],<_ip_to_AFR_Lookup
 0568 0E009E            adc [__r0],>_ip_to_AFR_Lookup
 056B 5100              mov A,[__r0]
 056D 10                push X
 056E 5800              mov X,[__r1]
 0570 28                romx
 0571 20                pop X
 0572 5300              mov [__r1],A
 0574 550000            mov [__r0],0
 0577 26000F            and [__r1],15
 057A 260000            and [__r0],0
 057D 0600DA            add [__r1],<_digitToSegment
 0580 0E00DA            adc [__r0],>_digitToSegment
 0583 5100              mov A,[__r0]
 0585 10                push X
 0586 5800              mov X,[__r1]
 0588 28                romx
 0589 20                pop X
 058A 5405              mov [X+5],A
 058C                   .dbline 650
 058C           ;                                               
 058C           ;                                               digits[0] = digitToSegment[1]; // temporarly first digit is always "1"
 058C 50DB              mov A,>_digitToSegment+1
 058E 10                push X
 058F 57DB              mov X,<_digitToSegment+1
 0591 28                romx
 0592 20                pop X
 0593 5403              mov [X+3],A
 0595                   .dbline 651
 0595           ;                                               TM1637_setSegments(digits, 3, 1);
 0595 5001              mov A,1
 0597 08                push A
 0598 5003              mov A,3
 059A 08                push A
 059B 5A00              mov [__r1],X
 059D 060003            add [__r1],3
 05A0 5100              mov A,[__r0]
 05A2 08                push A
 05A3 5100              mov A,[__r1]
 05A5 08                push A
 05A6 915A              xcall _TM1637_setSegments
 05A8 38FC              add SP,-4
 05AA                   .dbline 652
 05AA           ;                                       }       
 05AA           L62:
 05AA                   .dbline 665
 05AA           ;                               #else
 05AA           ;                                       // AFR integer part (temporarly first digit is always "1"), add dot
 05AA           ;                                       digits[0] = digitToSegment[(ip_to_AFR_Lookup[temp_byte] & 0xF0) >> 4] | 0x80;
 05AA           ;                               
 05AA           ;                                       // AFR decimal part
 05AA           ;                                       digits[1] = digitToSegment[ip_to_AFR_Lookup[temp_byte] & 0x0F];
 05AA           ;                               
 05AA           ;                                       TM1637_setSegments(digits, 2, 2);
 05AA           ;                               #endif
 05AA           ;                       #endif
 05AA           ;                       
 05AA           ;                       #ifdef LED_Lambda
 05AA           ;                               temp_int=ip-ip_to_LambdaD_Lookup_Start; 
 05AA 5106              mov A,[_ip+1]
 05AC 1187              sub A,-121
 05AE 5401              mov [X+1],A
 05B0 5105              mov A,[_ip]
 05B2 1900              sbb A,0
 05B4 5400              mov [X+0],A
 05B6                   .dbline 666
 05B6           ;                               if (temp_int<0)
 05B6 5201              mov A,[X+1]
 05B8 1100              sub A,0
 05BA 5200              mov A,[X+0]
 05BC 3180              xor A,-128
 05BE 1980              sbb A,(0 ^ 0x80)
 05C0 D007              jnc L67
 05C2           X37:
 05C2                   .dbline 668
 05C2           ;                               {
 05C2           ;                                       temp_int=0;
 05C2                   .dbline 668
 05C2 560100            mov [X+1],0
 05C5 560000            mov [X+0],0
 05C8                   .dbline 669
 05C8           ;                               }
 05C8           L67:
 05C8                   .dbline 670
 05C8           ;                               if (temp_int>(ip_to_LambdaD_Lookup_Size-1))
 05C8 509D              mov A,-99
 05CA 1301              sub A,[X+1]
 05CC 5200              mov A,[X+0]
 05CE 3180              xor A,-128
 05D0 5300              mov [__rX],A
 05D2 5080              mov A,(0 ^ 0x80)
 05D4 1A00              sbb A,[__rX]
 05D6 D007              jnc L69
 05D8           X38:
 05D8                   .dbline 672
 05D8           ;                               {
 05D8           ;                                       temp_int=(ip_to_LambdaD_Lookup_Size-1);
 05D8                   .dbline 672
 05D8 56019D            mov [X+1],-99
 05DB 560000            mov [X+0],0
 05DE                   .dbline 673
 05DE           ;                               }
 05DE           L69:
 05DE                   .dbline 674
 05DE           ;                               temp_byte = temp_int;   // code size optimization
 05DE 5201              mov A,[X+1]
 05E0 5402              mov [X+2],A
 05E2                   .dbline 677
 05E2           ;                               
 05E2           ;                               #ifdef LED_AFR
 05E2           ;                                       if ((SWPORT & SWPIN) != 0)
 05E2 5D04              mov A,REG[0x4]
 05E4 5300              mov [__r0],A
 05E6 470080            tst [__r0],-128
 05E9 A09F              jz L71
 05EB                   .dbline 680
 05EB           ;                                       {
 05EB           ;                                               // Lambda int part, add dot
 05EB           ;                                               if (temp_byte < 120)    // 120th value is equal to lambda 1.00
 05EB                   .dbline 680
 05EB 3D0278            cmp [X+2],120
 05EE D00E              jnc L73
 05F0           X39:
 05F0                   .dbline 681
 05F0           ;                                                       digits[0] = digitToSegment[0] | 0x80;
 05F0 50DA              mov A,>_digitToSegment
 05F2 10                push X
 05F3 57DA              mov X,<_digitToSegment
 05F5 28                romx
 05F6 20                pop X
 05F7 2980              or A,-128
 05F9 5403              mov [X+3],A
 05FB 800C              xjmp L74
 05FD           L73:
 05FD                   .dbline 683
 05FD           ;                                               else
 05FD           ;                                                       digits[0] = digitToSegment[1] | 0x80;
 05FD 50DB              mov A,>_digitToSegment+1
 05FF 10                push X
 0600 57DB              mov X,<_digitToSegment+1
 0602 28                romx
 0603 20                pop X
 0604 2980              or A,-128
 0606 5403              mov [X+3],A
 0608           L74:
 0608                   .dbline 686
 0608           ;                                       
 0608           ;                                               // Lambda 0.x0 part
 0608           ;                                               digits[1] = digitToSegment[(ip_to_Lambda_Lookup[temp_byte] & 0xF0) >> 4];
 0608 5202              mov A,[X+2]
 060A 5300              mov [__r1],A
 060C 550000            mov [__r0],0
 060F 06003C            add [__r1],<_ip_to_Lambda_Lookup
 0612 0E003C            adc [__r0],>_ip_to_Lambda_Lookup
 0615 5100              mov A,[__r0]
 0617 10                push X
 0618 5800              mov X,[__r1]
 061A 28                romx
 061B 20                pop X
 061C 5300              mov [__r1],A
 061E 550000            mov [__r0],0
 0621 2600F0            and [__r1],-16
 0624 260000            and [__r0],0
 0627 6800              asr [__r0]
 0629 6E00              rrc [__r1]
 062B 6800              asr [__r0]
 062D 6E00              rrc [__r1]
 062F 6800              asr [__r0]
 0631 6E00              rrc [__r1]
 0633 6800              asr [__r0]
 0635 6E00              rrc [__r1]
 0637 0600DA            add [__r1],<_digitToSegment
 063A 0E00DA            adc [__r0],>_digitToSegment
 063D 5100              mov A,[__r0]
 063F 10                push X
 0640 5800              mov X,[__r1]
 0642 28                romx
 0643 20                pop X
 0644 5404              mov [X+4],A
 0646                   .dbline 689
 0646           ;                                       
 0646           ;                                               // Lambda 0.0x part
 0646           ;                                               digits[2] = digitToSegment[ip_to_Lambda_Lookup[temp_byte] & 0x0F];
 0646 5202              mov A,[X+2]
 0648 5300              mov [__r1],A
 064A 550000            mov [__r0],0
 064D 06003C            add [__r1],<_ip_to_Lambda_Lookup
 0650 0E003C            adc [__r0],>_ip_to_Lambda_Lookup
 0653 5100              mov A,[__r0]
 0655 10                push X
 0656 5800              mov X,[__r1]
 0658 28                romx
 0659 20                pop X
 065A 5300              mov [__r1],A
 065C 550000            mov [__r0],0
 065F 26000F            and [__r1],15
 0662 260000            and [__r0],0
 0665 0600DA            add [__r1],<_digitToSegment
 0668 0E00DA            adc [__r0],>_digitToSegment
 066B 5100              mov A,[__r0]
 066D 10                push X
 066E 5800              mov X,[__r1]
 0670 28                romx
 0671 20                pop X
 0672 5405              mov [X+5],A
 0674                   .dbline 691
 0674           ;                                                       
 0674           ;                                               TM1637_setSegments(digits, 3, 1);
 0674 5001              mov A,1
 0676 08                push A
 0677 5003              mov A,3
 0679 08                push A
 067A 5A00              mov [__r1],X
 067C 060003            add [__r1],3
 067F 5100              mov A,[__r0]
 0681 08                push A
 0682 5100              mov A,[__r1]
 0684 08                push A
 0685 907B              xcall _TM1637_setSegments
 0687 38FC              add SP,-4
 0689                   .dbline 692
 0689           ;                                       }
 0689           L71:
 0689                   .dbline 709
 0689           ;                               #else
 0689           ;                                       // Lambda int part, add dot
 0689           ;                                       if (temp_byte < 120)    // 120th value is equal to lambda 1.00
 0689           ;                                               digits[0] = digitToSegment[0] | 0x80;
 0689           ;                                       else
 0689           ;                                               digits[0] = digitToSegment[1] | 0x80;
 0689           ;                                       
 0689           ;                                       // Lambda 0.x0 part
 0689           ;                                       digits[1] = digitToSegment[(ip_to_Lambda_Lookup[temp_byte] & 0xF0) >> 4];
 0689           ;                                       
 0689           ;                                       // Lambda 0.0x part
 0689           ;                                       digits[2] = digitToSegment[ip_to_Lambda_Lookup[temp_byte] & 0x0F];
 0689           ;                                                       
 0689           ;                                       TM1637_setSegments(digits, 3, 1);
 0689           ;                               #endif
 0689           ;                       #endif
 0689           ;               }
 0689           L56:
 0689                   .dbline 710
 0689           ;               if (Heatup_Heater_Output<255)
 0689 3C04FF            cmp [_Heatup_Heater_Output],-1
 068C DCAB              jnc L32
 068E           X40:
 068E                   .dbline 712
 068E           ;               {   
 068E           ;                       if (Heatup_Counter>Heatup_Counter_Set)
 068E                   .dbline 712
 068E 5064              mov A,100
 0690 3A09              cmp A,[_Heatup_Counter]
 0692 D006              jnc L80
 0694           X41:
 0694                   .dbline 714
 0694           ;                       {
 0694           ;                               Heatup_Counter=0;
 0694                   .dbline 714
 0694 550900            mov [_Heatup_Counter],0
 0697                   .dbline 715
 0697           ;                               Heatup_Heater_Output++;
 0697 7604              inc [_Heatup_Heater_Output]
 0699                   .dbline 716
 0699           ;                       }
 0699           L80:
 0699                   .dbline 717
 0699           ;                       if ((Ri_Min>50) && (Ri_Max<475) && (Ri_Delta<Ri_Delta_Target))
 0699 5032              mov A,50
 069B 120A              sub A,[_Ri_Min+1]
 069D 5109              mov A,[_Ri_Min]
 069F 3180              xor A,-128
 06A1 5300              mov [__rX],A
 06A3 5080              mov A,(0 ^ 0x80)
 06A5 1A00              sbb A,[__rX]
 06A7 DC90              jnc L32
 06A9           X42:
 06A9 5108              mov A,[_Ri_Max+1]
 06AB 11DB              sub A,-37
 06AD 5107              mov A,[_Ri_Max]
 06AF 3180              xor A,-128
 06B1 1981              sbb A,(1 ^ 0x80)
 06B3 DC84              jnc L32
 06B5           X43:
 06B5 511C              mov A,[_Ri_Delta+1]
 06B7 118F              sub A,-113
 06B9 511B              mov A,[_Ri_Delta]
 06BB 3180              xor A,-128
 06BD 1980              sbb A,(0 ^ 0x80)
 06BF DC78              jnc L32
 06C1           X44:
 06C1                   .dbline 719
 06C1           ;                       {
 06C1           ;                               Heatup_Heater_Output=255;
 06C1                   .dbline 719
 06C1 5504FF            mov [_Heatup_Heater_Output],-1
 06C4                   .dbline 720
 06C4           ;                               Ri_Delta_Error_Sum=0;
 06C4 550300            mov [_Ri_Delta_Error_Sum+1],0
 06C7 550200            mov [_Ri_Delta_Error_Sum],0
 06CA                   .dbline 721
 06CA           ;                       }
 06CA                   .dbline 722
 06CA           ;               }
 06CA                   .dbline 723
 06CA           ;       }
 06CA                   .dbline 430
 06CA                   .dbline 430
 06CA 8C6D              xjmp L32
 06CC           X25:
 06CC                   .dbline -2
 06CC           L30:
 06CC 38F3              add SP,-13
 06CE 20                pop X
 06CF                   .dbline 0 ; func end
 06CF 8FFF              jmp .
 06D1                   .dbsym l temp_int2 11 I
 06D1                   .dbsym l temp_ulong 7 l
 06D1                   .dbsym l digits 3 A[4:4]c
 06D1                   .dbsym l temp_byte 2 c
 06D1                   .dbsym l temp_int 0 I
 06D1                   .dbend
                        .area data(ram, con, rel)
 000A                   .dbfile I:\PSOCDO~1\WBOOS_~2\DSTAGE~1\DSTAGE~1\main.c
 000A           _m_brightness::
 000A                   .blkb 1
                        .area idata(rom,lit)
 000A 0C                .byte 12
                        .area data(ram, con, rel)
 000B                   .dbfile I:\PSOCDO~1\WBOOS_~2\DSTAGE~1\DSTAGE~1\main.c
 000B                   .dbsym e m_brightness _m_brightness c
                        .area text(rom, con, rel)
 06D1                   .dbfile I:\PSOCDO~1\WBOOS_~2\DSTAGE~1\DSTAGE~1\main.c
 06D1                   .dbfunc e TM1637_init _TM1637_init fV
 06D1           _TM1637_init::
 06D1                   .dbline -1
 06D1                   .dbline 834
 06D1           ; }
 06D1           ; 
 06D1           ; #if defined LED_AFR || defined LED_Lambda
 06D1           ; // ================================================================================
 06D1           ; // === TM1637 control functions ===================================================
 06D1           ; // ================================================================================
 06D1           ; 
 06D1           ; //  Modified (heavily) for PSoC 1 CY8C24423-24 by: dstagegarage@gmail.com
 06D1           ; //  Original author for Arduino: avishorp@gmail.com
 06D1           ; //
 06D1           ; //  This library is free software; you can redistribute it and/or
 06D1           ; //  modify it under the terms of the GNU Lesser General Public
 06D1           ; //  License as published by the Free Software Foundation; either
 06D1           ; //  version 2.1 of the License, or (at your option) any later version.
 06D1           ; //
 06D1           ; //  This library is distributed in the hope that it will be useful,
 06D1           ; //  but WITHOUT ANY WARRANTY; without even the implied warranty of
 06D1           ; //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 06D1           ; //  Lesser General Public License for more details.
 06D1           ; //
 06D1           ; //  You should have received a copy of the GNU Lesser General Public
 06D1           ; //  License along with this library; if not, write to the Free Software
 06D1           ; //  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 06D1           ; 
 06D1           ; // ----------------------------------------
 06D1           ; #if DIO_PORT == 1
 06D1           ;       #define DIOPORT PRT1DR
 06D1           ;       #define DIODM2 PRT1DM2
 06D1           ;       #define DIODM1 PRT1DM1
 06D1           ;       #define DIODM0 PRT1DM0
 06D1           ; #elif DIO_PORT == 2
 06D1           ;       #define DIOPORT PRT2DR
 06D1           ;       #define DIODM2 PRT2DM2
 06D1           ;       #define DIODM1 PRT2DM1
 06D1           ;       #define DIODM0 PRT2DM0
 06D1           ; #else
 06D1           ;       #define DIOPORT PRT0DR
 06D1           ;       #define DIODM2 PRT0DM2
 06D1           ;       #define DIODM1 PRT0DM1
 06D1           ;       #define DIODM0 PRT0DM0
 06D1           ; #endif
 06D1           ; #if CLK_PORT == 1
 06D1           ;       #define CLKPORT PRT1DR
 06D1           ;       #define CLKDM2 PRT1DM2
 06D1           ;       #define CLKDM1 PRT1DM1
 06D1           ;       #define CLKDM0 PRT1DM0
 06D1           ; #elif CLK_PORT == 2
 06D1           ;       #define CLKPORT PRT2DR
 06D1           ;       #define CLKDM2 PRT2DM2
 06D1           ;       #define CLKDM1 PRT2DM1
 06D1           ;       #define CLKDM0 PRT2DM0
 06D1           ; #else
 06D1           ;       #define CLKPORT PRT0DR
 06D1           ;       #define CLKDM2 PRT0DM2
 06D1           ;       #define CLKDM1 PRT0DM1
 06D1           ;       #define CLKDM0 PRT0DM0
 06D1           ; #endif
 06D1           ; #define DIOPIN (1 << DIO_PIN)
 06D1           ; #define CLKPIN (1 << CLK_PIN)
 06D1           ; #define TM1637_CLK_L CLKPORT &= ~CLKPIN
 06D1           ; #define TM1637_CLK_H CLKPORT |= CLKPIN
 06D1           ; #define TM1637_DIO_L DIOPORT &= ~DIOPIN
 06D1           ; #define TM1637_DIO_H DIOPORT |= DIOPIN
 06D1           ; #define TM1637_DIO_READ DIOPORT & DIOPIN
 06D1           ; /*#define IOPIN7      0x80
 06D1           ; #define TM1637_CLK_L PRT1DR &= ~IOPIN7
 06D1           ; #define TM1637_CLK_H PRT1DR |= IOPIN7
 06D1           ; #define TM1637_DIO_L PRT2DR &= ~IOPIN7
 06D1           ; #define TM1637_DIO_H PRT2DR |= IOPIN7
 06D1           ; #define TM1637_DIO_READ PRT2DR & IOPIN7*/
 06D1           ; 
 06D1           ; #define BITDELAY 2
 06D1           ; 
 06D1           ; #define TM1637_I2C_COMM1    0x40
 06D1           ; #define TM1637_I2C_COMM2    0xC0
 06D1           ; #define TM1637_I2C_COMM3    0x80
 06D1           ; 
 06D1           ; BYTE m_brightness = 0x0C;
 06D1           ; 
 06D1           ; /* moved to the top of main.c//
 06D1           ; //      A
 06D1           ; //     ---
 06D1           ; //  F |   | B
 06D1           ; //     -G-
 06D1           ; //  E |   | C
 06D1           ; //     ---
 06D1           ; //      D
 06D1           ; const BYTE digitToSegment[] = {
 06D1           ;  // XGFEDCBA
 06D1           ;   0b00111111,    // 0
 06D1           ;   0b00000110,    // 1
 06D1           ;   0b01011011,    // 2
 06D1           ;   0b01001111,    // 3
 06D1           ;   0b01100110,    // 4
 06D1           ;   0b01101101,    // 5
 06D1           ;   0b01111101,    // 6
 06D1           ;   0b00000111,    // 7
 06D1           ;   0b01111111,    // 8
 06D1           ;   0b01101111,    // 9
 06D1           ;   //0b01110111,    // A
 06D1           ;   //0b01111100,    // b
 06D1           ;   //0b00111001,    // C
 06D1           ;   //0b01011110,    // d
 06D1           ;   //0b01111001,    // E
 06D1           ;   //0b01110001     // F
 06D1           ;   };*/
 06D1           ; 
 06D1           ; //static const BYTE minusSegments = 0b01000000;
 06D1           ; 
 06D1           ; void TM1637_init(void)
 06D1           ; {
 06D1                   .dbline 841
 06D1           ;       // DStage DSpeed has extra pads for pins P1.7 and P2.7 and programming pins P1.0 and P1.1
 06D1           ;       // DStage WBOOS has extra pads for pins P0.4, P1.2, P1.3, P1.7, P2.7, programming pins P1.0 and P1.1 and all LCD pins are free in this mode
 06D1           ;       
 06D1           ;       // CLK line 
 06D1           ;       // 001 strong high and low; theoritically it should be resistive high strong low to allow for display response but
 06D1           ;       // it requires stronger pull-up resistor most likey and was ustable in experiments, would be good to check current when ACK i aplied by the display
 06D1           ;       CLKDM2 &= ~CLKPIN;
 06D1 4107FD            and REG[0x7],-3
 06D4                   .dbline 842
 06D4           ;       CLKDM1 &= ~CLKPIN;
 06D4 7110              or F,0x10  ; iopage = 1
 06D6 4105FD            and REG[0x5],-3
 06D9                   .dbline 843
 06D9           ;       CLKDM0 |= CLKPIN;
 06D9 430402            or REG[0x4],2
 06DC                   .dbline 844
 06DC           ;       TM1637_CLK_H;
 06DC 70CF              and F,0xCF      ; iopage = 0
 06DE 430402            or REG[0x4],2
 06E1                   .dbline 849
 06E1           ;       
 06E1           ;       // DIO line
 06E1           ;       // 001 strong high and low; theoritically it should be resistive high strong low to allow for display response but
 06E1           ;       // it requires stronger pull-up resistor most likey and was ustable in experiments, would be good to check current when ACK i aplied by the display
 06E1           ;       DIODM2 &= ~DIOPIN;
 06E1 4107FE            and REG[0x7],-2
 06E4                   .dbline 850
 06E4           ;       DIODM1 &= ~DIOPIN;
 06E4 7110              or F,0x10  ; iopage = 1
 06E6 4105FE            and REG[0x5],-2
 06E9                   .dbline 851
 06E9           ;       DIODM0 |= DIOPIN;
 06E9 430401            or REG[0x4],1
 06EC                   .dbline 852
 06EC           ;       TM1637_DIO_H;
 06EC 70CF              and F,0xCF      ; iopage = 0
 06EE 430401            or REG[0x4],1
 06F1                   .dbline 857
 06F1           ;       
 06F1           ;       #if defined LED_AFR && defined LED_Lambda
 06F1           ;               // LED AFR/Lambda switch line
 06F1           ;               // 011 resistive high (pull-up), strong low -> used as input with pull-up, recommended external pull-up or direct high/low state switching
 06F1           ;               SWDM2 &= ~SWPIN;
 06F1 41077F            and REG[0x7],127
 06F4                   .dbline 858
 06F4           ;               SWDM1 |= SWPIN;
 06F4 7110              or F,0x10  ; iopage = 1
 06F6 430580            or REG[0x5],-128
 06F9                   .dbline 859
 06F9           ;               SWDM0 |= SWPIN;
 06F9 430480            or REG[0x4],-128
 06FC                   .dbline 860
 06FC           ;               SWPORT |= SWPIN;
 06FC 70CF              and F,0xCF      ; iopage = 0
 06FE 430480            or REG[0x4],-128
 0701                   .dbline -2
 0701           L84:
 0701                   .dbline 0 ; func end
 0701 7F                ret
 0702                   .dbend
 0702                   .dbfunc e TM1637_setSegments _TM1637_setSegments fV
 0702           ;              k -> X+0
 0702           ;            pos -> X-7
 0702           ;         length -> X-6
 0702           ;       segments -> X-5
 0702           _TM1637_setSegments::
 0702                   .dbline -1
 0702 10                push X
 0703 4F                mov X,SP
 0704 3801              add SP,1
 0706                   .dbline 870
 0706           ;       #endif
 0706           ; }
 0706           ; 
 0706           ; /*void TM1637_setBrightness(BYTE brightness, BYTE on)
 0706           ; {
 0706           ;       m_brightness = (brightness & 0x7) | (on? 0x08 : 0x00);
 0706           ; }*/
 0706           ; 
 0706           ; void TM1637_setSegments(BYTE segments[], BYTE length, BYTE pos)
 0706           ; {
 0706                   .dbline 873
 0706           ;       BYTE k;
 0706           ;     // Write COMM1
 0706           ;       TM1637_start();
 0706 9045              xcall _TM1637_start
 0708                   .dbline 874
 0708           ;       TM1637_writeByte(TM1637_I2C_COMM1);
 0708 5040              mov A,64
 070A 08                push A
 070B 906A              xcall _TM1637_writeByte
 070D                   .dbline 875
 070D           ;       TM1637_stop();
 070D 9049              xcall _TM1637_stop
 070F                   .dbline 878
 070F           ; 
 070F           ;       // Write COMM2 + first digit address
 070F           ;       TM1637_start();
 070F 903C              xcall _TM1637_start
 0711                   .dbline 879
 0711           ;       TM1637_writeByte(TM1637_I2C_COMM2 + (pos & 0x03));
 0711 52F9              mov A,[X-7]
 0713 2103              and A,3
 0715 01C0              add A,-64
 0717 08                push A
 0718 905D              xcall _TM1637_writeByte
 071A 38FE              add SP,-2
 071C                   .dbline 882
 071C           ; 
 071C           ;       // Write the data bytes
 071C           ;       for (k=0; k < length; k++)
 071C 560000            mov [X+0],0
 071F 8012              xjmp L89
 0721           L86:
 0721                   .dbline 883
 0721           ;         TM1637_writeByte(segments[k]);
 0721 5200              mov A,[X+0]
 0723 5300              mov [__r1],A
 0725 52FC              mov A,[X-4]
 0727 0400              add [__r1],A
 0729 3E00              mvi A,[__r1]
 072B 08                push A
 072C 9049              xcall _TM1637_writeByte
 072E 38FF              add SP,-1
 0730           L87:
 0730                   .dbline 882
 0730 7700              inc [X+0]
 0732           L89:
 0732                   .dbline 882
 0732 5200              mov A,[X+0]
 0734 3BFA              cmp A,[X-6]
 0736 CFEA              jc L86
 0738           X45:
 0738                   .dbline 885
 0738           ; 
 0738           ;       TM1637_stop();
 0738 901E              xcall _TM1637_stop
 073A                   .dbline 888
 073A           ; 
 073A           ;       // Write COMM3 + brightness
 073A           ;       TM1637_start();
 073A 9011              xcall _TM1637_start
 073C                   .dbline 889
 073C           ;       TM1637_writeByte(TM1637_I2C_COMM3 + (m_brightness & 0x0f));
 073C 510A              mov A,[_m_brightness]
 073E 210F              and A,15
 0740 0180              add A,-128
 0742 08                push A
 0743 9032              xcall _TM1637_writeByte
 0745 38FF              add SP,-1
 0747                   .dbline 890
 0747           ;       TM1637_stop();
 0747 900F              xcall _TM1637_stop
 0749                   .dbline -2
 0749           L85:
 0749 38FF              add SP,-1
 074B 20                pop X
 074C                   .dbline 0 ; func end
 074C 7F                ret
 074D                   .dbsym l k 0 c
 074D                   .dbsym l pos -7 c
 074D                   .dbsym l length -6 c
 074D                   .dbsym l segments -5 pc
 074D                   .dbend
 074D                   .dbfunc e TM1637_start _TM1637_start fV
 074D           _TM1637_start::
 074D                   .dbline -1
 074D                   .dbline 977
 074D           ; }
 074D           ; 
 074D           ; /*void TM1637_clear()
 074D           ; {
 074D           ;     BYTE data[] = { 0, 0, 0, 0 };
 074D           ;       TM1637_setSegments(data);
 074D           ; }*/
 074D           ; /*
 074D           ; void TM1637_showNumberDec(int num, BYTE leading_zero, BYTE length, BYTE pos)
 074D           ; {
 074D           ;   TM1637_showNumberDecEx(num, 0, leading_zero, length, pos);
 074D           ; }
 074D           ; 
 074D           ; void TM1637_showNumberDecEx(int num, BYTE dots, BYTE leading_zero, BYTE length, BYTE pos)
 074D           ; {
 074D           ;   TM1637_showNumberBaseEx(num < 0? -10 : 10, num < 0? -num : num, dots, leading_zero, length, pos);
 074D           ; }
 074D           ; 
 074D           ; void TM1637_showNumberHexEx(unsigned int num, BYTE dots, BYTE leading_zero, BYTE length, BYTE pos)
 074D           ; {
 074D           ;   TM1637_showNumberBaseEx(16, num, dots, leading_zero, length, pos);
 074D           ; }
 074D           ; 
 074D           ; void TM1637_showNumberBaseEx(BYTE base, unsigned int num, BYTE dots, BYTE leading_zero, BYTE length, BYTE pos)
 074D           ; {
 074D           ;       int i;
 074D           ;     BYTE negative = 0;
 074D           ;       BYTE digits[4];
 074D           ;       BYTE digit;
 074D           ;       
 074D           ;       if (base < 0) 
 074D           ;       {
 074D           ;           base = -base;
 074D           ;               negative = 1;
 074D           ;       }
 074D           ; 
 074D           ;       if (num == 0 && !leading_zero) 
 074D           ;       {
 074D           ;               // Singular case - take care separately
 074D           ;               for(i = 0; i < (length-1); i++)
 074D           ;                       digits[i] = 0;
 074D           ;               digits[length-1] = TM1637_encodeDigit(0);
 074D           ;       }
 074D           ;       else 
 074D           ;       {
 074D           ;               //uint8_t i = length-1;
 074D           ;               //if (negative) {
 074D           ;               //      // Negative number, show the minus sign
 074D           ;               //    digits[i] = minusSegments;
 074D           ;               //      i--;
 074D           ;               //}
 074D           ;               
 074D           ;               for(i = length-1; i >= 0; --i)
 074D           ;               {
 074D           ;                   digit = num % base;
 074D           ;                       
 074D           ;                       if (digit == 0 && num == 0 && leading_zero == 0)
 074D           ;                           // Leading zero is blank
 074D           ;                               digits[i] = 0;
 074D           ;                       else
 074D           ;                           digits[i] = TM1637_encodeDigit(digit);
 074D           ;                               
 074D           ;                       if (digit == 0 && num == 0 && negative) 
 074D           ;                       {
 074D           ;                           digits[i] = minusSegments;
 074D           ;                               negative = 0;
 074D           ;                       }
 074D           ; 
 074D           ;                       num /= base;
 074D           ;               }
 074D           ;     }
 074D           ;       
 074D           ;       if(dots != 0)
 074D           ;       {
 074D           ;               TM1637_showDots(dots, digits);
 074D           ;       }
 074D           ;     
 074D           ;     TM1637_setSegments(digits, length, pos);
 074D           ; }
 074D           ; */
 074D           ; /*void TM1637_LCD_Delay50uTimes(BITDELAY)
 074D           ; {
 074D           ;       TM1637_delayMicroseconds(m_bitDelay);
 074D           ; }*/
 074D           ; 
 074D           ; void TM1637_start(void)
 074D           ; {
 074D                   .dbline 978
 074D           ;   TM1637_DIO_L;
 074D 4104FE            and REG[0x4],-2
 0750                   .dbline 979
 0750           ;   LCD_Delay50uTimes(BITDELAY);
 0750 10                push X
 0751 5002              mov A,2
 0753 7C0000            xcall _LCD_Delay50uTimes
 0756 20                pop X
 0757                   .dbline -2
 0757           L90:
 0757                   .dbline 0 ; func end
 0757 7F                ret
 0758                   .dbend
 0758                   .dbfunc e TM1637_stop _TM1637_stop fV
 0758           _TM1637_stop::
 0758                   .dbline -1
 0758                   .dbline 983
 0758           ; }
 0758           ; 
 0758           ; void TM1637_stop(void)
 0758           ; {
 0758                   .dbline 984
 0758           ;       TM1637_DIO_L;
 0758 4104FE            and REG[0x4],-2
 075B                   .dbline 985
 075B           ;       LCD_Delay50uTimes(BITDELAY);
 075B 10                push X
 075C 5002              mov A,2
 075E 7C0000            xcall _LCD_Delay50uTimes
 0761 20                pop X
 0762                   .dbline 986
 0762           ;       TM1637_CLK_H;
 0762 430402            or REG[0x4],2
 0765                   .dbline 987
 0765           ;       LCD_Delay50uTimes(BITDELAY);
 0765 10                push X
 0766 5002              mov A,2
 0768 7C0000            xcall _LCD_Delay50uTimes
 076B 20                pop X
 076C                   .dbline 988
 076C           ;       TM1637_DIO_H;
 076C 430401            or REG[0x4],1
 076F                   .dbline 989
 076F           ;       LCD_Delay50uTimes(BITDELAY);
 076F 10                push X
 0770 5002              mov A,2
 0772 7C0000            xcall _LCD_Delay50uTimes
 0775 20                pop X
 0776                   .dbline -2
 0776           L91:
 0776                   .dbline 0 ; func end
 0776 7F                ret
 0777                   .dbend
 0777                   .dbfunc e TM1637_writeByte _TM1637_writeByte fc
 0777           ;            ack -> X+2
 0777           ;              i -> X+1
 0777           ;           data -> X+0
 0777           ;              b -> X-4
 0777           _TM1637_writeByte::
 0777                   .dbline -1
 0777 10                push X
 0778 4F                mov X,SP
 0779 3803              add SP,3
 077B                   .dbline 993
 077B           ; }
 077B           ; 
 077B           ; BYTE TM1637_writeByte(BYTE b)
 077B           ; {
 077B                   .dbline 994
 077B           ;   BYTE data = b;
 077B 52FC              mov A,[X-4]
 077D 5400              mov [X+0],A
 077F                   .dbline 998
 077F           ;   BYTE i, ack;
 077F           ; 
 077F           ;   // 8 Data Bits
 077F           ;   for(i = 0; i < 8; i++) {
 077F 560100            mov [X+1],0
 0782 802F              xjmp L96
 0784           L93:
 0784                   .dbline 998
 0784                   .dbline 1000
 0784           ;     // CLK low
 0784           ;     TM1637_CLK_L;
 0784 4104FD            and REG[0x4],-3
 0787                   .dbline 1001
 0787           ;     LCD_Delay50uTimes(BITDELAY);
 0787 10                push X
 0788 5002              mov A,2
 078A 7C0000            xcall _LCD_Delay50uTimes
 078D 20                pop X
 078E                   .dbline 1004
 078E           ; 
 078E           ;       // Set data bit
 078E           ;     if (data & 0x01)
 078E 480001            tst [X+0],1
 0791 A006              jz L97
 0793                   .dbline 1005
 0793           ;       TM1637_DIO_H;
 0793 430401            or REG[0x4],1
 0796 8004              xjmp L98
 0798           L97:
 0798                   .dbline 1007
 0798           ;     else
 0798           ;       TM1637_DIO_L;
 0798 4104FE            and REG[0x4],-2
 079B           L98:
 079B                   .dbline 1009
 079B           ; 
 079B           ;     LCD_Delay50uTimes(BITDELAY);
 079B 10                push X
 079C 5002              mov A,2
 079E 7C0000            xcall _LCD_Delay50uTimes
 07A1 20                pop X
 07A2                   .dbline 1012
 07A2           ; 
 07A2           ;       // CLK high
 07A2           ;     TM1637_CLK_H;
 07A2 430402            or REG[0x4],2
 07A5                   .dbline 1013
 07A5           ;     LCD_Delay50uTimes(BITDELAY);
 07A5 10                push X
 07A6 5002              mov A,2
 07A8 7C0000            xcall _LCD_Delay50uTimes
 07AB 20                pop X
 07AC                   .dbline 1014
 07AC           ;     data = data >> 1;
 07AC 70FB              and F,-5
 07AE 6F00              rrc [X+0]
 07B0                   .dbline 1015
 07B0           ;   }
 07B0           L94:
 07B0                   .dbline 998
 07B0 7701              inc [X+1]
 07B2           L96:
 07B2                   .dbline 998
 07B2 3D0108            cmp [X+1],8
 07B5 CFCE              jc L93
 07B7           X46:
 07B7                   .dbline 1019
 07B7           ; 
 07B7           ;   // Wait for acknowledge
 07B7           ;   // CLK to zero
 07B7           ;   TM1637_CLK_L;
 07B7 4104FD            and REG[0x4],-3
 07BA                   .dbline 1020
 07BA           ;   TM1637_DIO_H;
 07BA 430401            or REG[0x4],1
 07BD                   .dbline 1021
 07BD           ;   LCD_Delay50uTimes(BITDELAY);
 07BD 10                push X
 07BE 5002              mov A,2
 07C0 7C0000            xcall _LCD_Delay50uTimes
 07C3 20                pop X
 07C4                   .dbline 1024
 07C4           ; 
 07C4           ;   // CLK to high
 07C4           ;   TM1637_CLK_H;
 07C4 430402            or REG[0x4],2
 07C7                   .dbline 1025
 07C7           ;   LCD_Delay50uTimes(BITDELAY);
 07C7 10                push X
 07C8 5002              mov A,2
 07CA 7C0000            xcall _LCD_Delay50uTimes
 07CD 20                pop X
 07CE                   .dbline 1026
 07CE           ;   ack = TM1637_DIO_READ; //digitalRead(m_pinDIO);
 07CE 5D04              mov A,REG[0x4]
 07D0 2101              and A,1
 07D2 5402              mov [X+2],A
 07D4                   .dbline 1027
 07D4           ;   if (ack == 0)
 07D4 3D0200            cmp [X+2],0
 07D7 B004              jnz L99
 07D9                   .dbline 1028
 07D9           ;     TM1637_DIO_L;
 07D9 4104FE            and REG[0x4],-2
 07DC           L99:
 07DC                   .dbline 1030
 07DC           ; 
 07DC           ;   LCD_Delay50uTimes(BITDELAY);
 07DC 10                push X
 07DD 5002              mov A,2
 07DF 7C0000            xcall _LCD_Delay50uTimes
 07E2 20                pop X
 07E3                   .dbline 1031
 07E3           ;   TM1637_CLK_L;
 07E3 4104FD            and REG[0x4],-3
 07E6                   .dbline 1032
 07E6           ;   LCD_Delay50uTimes(BITDELAY);
 07E6 10                push X
 07E7 5002              mov A,2
 07E9 7C0000            xcall _LCD_Delay50uTimes
 07EC 20                pop X
 07ED                   .dbline 1034
 07ED           ;   
 07ED           ;   if (ack == 0)
 07ED 3D0200            cmp [X+2],0
 07F0 B005              jnz L101
 07F2                   .dbline 1035
 07F2           ;       return 0;
 07F2 5000              mov A,0
 07F4 8003              xjmp L92
 07F6           L101:
 07F6                   .dbline 1037
 07F6           ;   else
 07F6           ;     return 1;
 07F6 5001              mov A,1
 07F8                   .dbline -2
 07F8           L92:
 07F8 38FD              add SP,-3
 07FA 20                pop X
 07FB                   .dbline 0 ; func end
 07FB 7F                ret
 07FC                   .dbsym l ack 2 c
 07FC                   .dbsym l i 1 c
 07FC                   .dbsym l data 0 c
 07FC                   .dbsym l b -4 c
 07FC                   .dbend
                        .area bss(ram, con, rel)
 0000                   .dbfile I:\PSOCDO~1\WBOOS_~2\DSTAGE~1\DSTAGE~1\main.c
 0000           _LSU_Temperature_C::
 0000                   .blkb 2
 0002                   .dbsym e LSU_Temperature_C _LSU_Temperature_C I
 0002           _Lambda_x100::
 0002                   .blkb 1
 0003                   .dbsym e Lambda_x100 _Lambda_x100 c
 0003           _ip_Justified::
 0003                   .blkb 2
 0005                   .dbsym e ip_Justified _ip_Justified I
 0005           _ip::
 0005                   .blkb 2
 0007                   .dbsym e ip _ip I
 0007           _Ri_Max::
 0007                   .blkb 2
 0009                   .dbsym e Ri_Max _Ri_Max I
 0009           _Ri_Min::
 0009                   .blkb 2
 000B                   .dbsym e Ri_Min _Ri_Min I
 000B           _Ia_Iout::
 000B                   .blkb 2
 000D                   .dbsym e Ia_Iout _Ia_Iout I
 000D           _Ia_Pout::
 000D                   .blkb 2
 000F                   .dbsym e Ia_Pout _Ia_Pout I
 000F           _Ia_Output::
 000F                   .blkb 2
 0011                   .dbsym e Ia_Output _Ia_Output I
 0011           _Ri_Mid_Error::
 0011                   .blkb 2
 0013                   .dbsym e Ri_Mid_Error _Ri_Mid_Error I
 0013           _Heater_Iout::
 0013                   .blkb 2
 0015                   .dbsym e Heater_Iout _Heater_Iout I
 0015           _Heater_Pout::
 0015                   .blkb 2
 0017                   .dbsym e Heater_Pout _Heater_Pout I
 0017           _Heater_Output::
 0017                   .blkb 2
 0019                   .dbsym e Heater_Output _Heater_Output I
 0019           _Ri_Delta_Error::
 0019                   .blkb 2
 001B                   .dbsym e Ri_Delta_Error _Ri_Delta_Error I
 001B           _Ri_Delta::
 001B                   .blkb 2
 001D                   .dbsym e Ri_Delta _Ri_Delta I
 001D           _Ri_Mid::
 001D                   .blkb 2
 001F                   .dbsym e Ri_Mid _Ri_Mid I
